<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>用PyInstaller打包python应用 | Trim21&#39;s</title>
<meta name="keywords" content="python">
<meta name="description" content="那天突然好奇，docker-compose是用什么语言写的。然后一看，发现居然是用 python2 写的。
但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用PyInstaller来进行打包的，把一个 python 应用打包成单个的二进制文件。
一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。
但用PyInstaller，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。
首先，PyInstaller 的工作原理是从一个 py 文件出发在静态分析出所有用到的依赖，然后把所有的依赖打包起来，在用户使用二进制的时候释放到一个临时文件夹中，用 Python 解释器来运行。
PyInstaller 入门的文章已经有很多了，就不再重复写一遍了，主要遇到的坑有这么几个。
用到的非 py 文件要手动指定路径一起打包
我的程序中用到了一些模板文件，是在程序运行起来之后才根据需要加载决定是否渲染的。这些文件因为不是 python 文件，所以 PyInstaller 在分析的时候也不会知道是程序的一部分，就不会打包在二进制中。
在程序运行的时候，如果用到了对应的文件，因为没有被打包进来的缘故，程序就会报错。
如果用命令行来指定要一起打包的文件效率过低，所以可以编写一个 spec 文件来告诉 PyInstaller 要如何打包。
（这是我之前尝试打包我的程序是用到的 spec 文件，但是因为不支持entry_points的原因，所以我最后放弃了使用这个办法，但是打包出来的程序在不用到entry_points的情况下是跟直接使用 pip 安装行为一致的。）
bgmi.spec
# -*- mode: python -*-
from PyInstaller.building.api import EXE, PYZ
from PyInstaller.building.build_main import Analysis

import os
import os.path
import importlib

bindata_dir = [
    &#39;bgmi/front/templates&#39;,
    &#39;bgmi/lib/models/migrations&#39;,
]


def get_bindata():
    for dir_path in bindata_dir:
        for file in os.listdir(dir_path):
            yield (os.path.join(dir_path, file), dir_path)


block_cipher = None

package_imports = [[&#39;peewee_migrate&#39;, [&#39;template.txt&#39;]]]
datas = list(get_bindata())

for package, files in package_imports:
    proot = os.path.dirname(importlib.import_module(package).__file__)
    datas.extend((os.path.join(proot, f), package) for f in files)

a = Analysis([&#39;bgmi/__main__.py&#39;],
             pathex=[&#39;.&#39;],
             hiddenimports=[],
             hookspath=None,
             datas=datas,
             runtime_hooks=None,
             cipher=block_cipher)

pyz = PYZ(a.pure, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    name=&#39;bgmi&#39;,
    debug=False,
    strip=None,
    upx=True,
    console=True,
    bootloader_ignore_signals=True,
)
其中，a = Analysis([&#39;bgmi/__main__.py&#39;],为程序的入口就是原本如果使用命令行的话，在 PyInstaller 后面跟的那个 py 文件路径。">
<meta name="author" content="">
<link rel="canonical" href="https://blog.trim21.me/posts/build-python-package-with-pyinstaller/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.trim21.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.trim21.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.trim21.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.trim21.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.trim21.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.trim21.me/posts/build-python-package-with-pyinstaller/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.trim21.me/posts/build-python-package-with-pyinstaller/">
  <meta property="og:site_name" content="Trim21&#39;s">
  <meta property="og:title" content="用PyInstaller打包python应用">
  <meta property="og:description" content="那天突然好奇，docker-compose是用什么语言写的。然后一看，发现居然是用 python2 写的。
但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用PyInstaller来进行打包的，把一个 python 应用打包成单个的二进制文件。
一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。
但用PyInstaller，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。
首先，PyInstaller 的工作原理是从一个 py 文件出发在静态分析出所有用到的依赖，然后把所有的依赖打包起来，在用户使用二进制的时候释放到一个临时文件夹中，用 Python 解释器来运行。
PyInstaller 入门的文章已经有很多了，就不再重复写一遍了，主要遇到的坑有这么几个。
用到的非 py 文件要手动指定路径一起打包 我的程序中用到了一些模板文件，是在程序运行起来之后才根据需要加载决定是否渲染的。这些文件因为不是 python 文件，所以 PyInstaller 在分析的时候也不会知道是程序的一部分，就不会打包在二进制中。
在程序运行的时候，如果用到了对应的文件，因为没有被打包进来的缘故，程序就会报错。
如果用命令行来指定要一起打包的文件效率过低，所以可以编写一个 spec 文件来告诉 PyInstaller 要如何打包。
（这是我之前尝试打包我的程序是用到的 spec 文件，但是因为不支持entry_points的原因，所以我最后放弃了使用这个办法，但是打包出来的程序在不用到entry_points的情况下是跟直接使用 pip 安装行为一致的。）
bgmi.spec
# -*- mode: python -*- from PyInstaller.building.api import EXE, PYZ from PyInstaller.building.build_main import Analysis import os import os.path import importlib bindata_dir = [ &#39;bgmi/front/templates&#39;, &#39;bgmi/lib/models/migrations&#39;, ] def get_bindata(): for dir_path in bindata_dir: for file in os.listdir(dir_path): yield (os.path.join(dir_path, file), dir_path) block_cipher = None package_imports = [[&#39;peewee_migrate&#39;, [&#39;template.txt&#39;]]] datas = list(get_bindata()) for package, files in package_imports: proot = os.path.dirname(importlib.import_module(package).__file__) datas.extend((os.path.join(proot, f), package) for f in files) a = Analysis([&#39;bgmi/__main__.py&#39;], pathex=[&#39;.&#39;], hiddenimports=[], hookspath=None, datas=datas, runtime_hooks=None, cipher=block_cipher) pyz = PYZ(a.pure, cipher=block_cipher) exe = EXE( pyz, a.scripts, a.binaries, a.zipfiles, a.datas, name=&#39;bgmi&#39;, debug=False, strip=None, upx=True, console=True, bootloader_ignore_signals=True, ) 其中，a = Analysis([&#39;bgmi/__main__.py&#39;],为程序的入口就是原本如果使用命令行的话，在 PyInstaller 后面跟的那个 py 文件路径。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-06-02T23:47:34+08:00">
    <meta property="article:modified_time" content="2025-03-03T05:55:21+08:00">
    <meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用PyInstaller打包python应用">
<meta name="twitter:description" content="那天突然好奇，docker-compose是用什么语言写的。然后一看，发现居然是用 python2 写的。
但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用PyInstaller来进行打包的，把一个 python 应用打包成单个的二进制文件。
一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。
但用PyInstaller，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。
首先，PyInstaller 的工作原理是从一个 py 文件出发在静态分析出所有用到的依赖，然后把所有的依赖打包起来，在用户使用二进制的时候释放到一个临时文件夹中，用 Python 解释器来运行。
PyInstaller 入门的文章已经有很多了，就不再重复写一遍了，主要遇到的坑有这么几个。
用到的非 py 文件要手动指定路径一起打包
我的程序中用到了一些模板文件，是在程序运行起来之后才根据需要加载决定是否渲染的。这些文件因为不是 python 文件，所以 PyInstaller 在分析的时候也不会知道是程序的一部分，就不会打包在二进制中。
在程序运行的时候，如果用到了对应的文件，因为没有被打包进来的缘故，程序就会报错。
如果用命令行来指定要一起打包的文件效率过低，所以可以编写一个 spec 文件来告诉 PyInstaller 要如何打包。
（这是我之前尝试打包我的程序是用到的 spec 文件，但是因为不支持entry_points的原因，所以我最后放弃了使用这个办法，但是打包出来的程序在不用到entry_points的情况下是跟直接使用 pip 安装行为一致的。）
bgmi.spec
# -*- mode: python -*-
from PyInstaller.building.api import EXE, PYZ
from PyInstaller.building.build_main import Analysis

import os
import os.path
import importlib

bindata_dir = [
    &#39;bgmi/front/templates&#39;,
    &#39;bgmi/lib/models/migrations&#39;,
]


def get_bindata():
    for dir_path in bindata_dir:
        for file in os.listdir(dir_path):
            yield (os.path.join(dir_path, file), dir_path)


block_cipher = None

package_imports = [[&#39;peewee_migrate&#39;, [&#39;template.txt&#39;]]]
datas = list(get_bindata())

for package, files in package_imports:
    proot = os.path.dirname(importlib.import_module(package).__file__)
    datas.extend((os.path.join(proot, f), package) for f in files)

a = Analysis([&#39;bgmi/__main__.py&#39;],
             pathex=[&#39;.&#39;],
             hiddenimports=[],
             hookspath=None,
             datas=datas,
             runtime_hooks=None,
             cipher=block_cipher)

pyz = PYZ(a.pure, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    name=&#39;bgmi&#39;,
    debug=False,
    strip=None,
    upx=True,
    console=True,
    bootloader_ignore_signals=True,
)
其中，a = Analysis([&#39;bgmi/__main__.py&#39;],为程序的入口就是原本如果使用命令行的话，在 PyInstaller 后面跟的那个 py 文件路径。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "posts",
      "item": "https://blog.trim21.me/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "用PyInstaller打包python应用",
      "item": "https://blog.trim21.me/posts/build-python-package-with-pyinstaller/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "用PyInstaller打包python应用",
  "name": "用PyInstaller打包python应用",
  "description": "那天突然好奇，docker-compose是用什么语言写的。然后一看，发现居然是用 python2 写的。\n但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用PyInstaller来进行打包的，把一个 python 应用打包成单个的二进制文件。\n一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。\n但用PyInstaller，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。\n首先，PyInstaller 的工作原理是从一个 py 文件出发在静态分析出所有用到的依赖，然后把所有的依赖打包起来，在用户使用二进制的时候释放到一个临时文件夹中，用 Python 解释器来运行。\nPyInstaller 入门的文章已经有很多了，就不再重复写一遍了，主要遇到的坑有这么几个。\n用到的非 py 文件要手动指定路径一起打包 我的程序中用到了一些模板文件，是在程序运行起来之后才根据需要加载决定是否渲染的。这些文件因为不是 python 文件，所以 PyInstaller 在分析的时候也不会知道是程序的一部分，就不会打包在二进制中。\n在程序运行的时候，如果用到了对应的文件，因为没有被打包进来的缘故，程序就会报错。\n如果用命令行来指定要一起打包的文件效率过低，所以可以编写一个 spec 文件来告诉 PyInstaller 要如何打包。\n（这是我之前尝试打包我的程序是用到的 spec 文件，但是因为不支持entry_points的原因，所以我最后放弃了使用这个办法，但是打包出来的程序在不用到entry_points的情况下是跟直接使用 pip 安装行为一致的。）\nbgmi.spec\n# -*- mode: python -*- from PyInstaller.building.api import EXE, PYZ from PyInstaller.building.build_main import Analysis import os import os.path import importlib bindata_dir = [ \u0026#39;bgmi/front/templates\u0026#39;, \u0026#39;bgmi/lib/models/migrations\u0026#39;, ] def get_bindata(): for dir_path in bindata_dir: for file in os.listdir(dir_path): yield (os.path.join(dir_path, file), dir_path) block_cipher = None package_imports = [[\u0026#39;peewee_migrate\u0026#39;, [\u0026#39;template.txt\u0026#39;]]] datas = list(get_bindata()) for package, files in package_imports: proot = os.path.dirname(importlib.import_module(package).__file__) datas.extend((os.path.join(proot, f), package) for f in files) a = Analysis([\u0026#39;bgmi/__main__.py\u0026#39;], pathex=[\u0026#39;.\u0026#39;], hiddenimports=[], hookspath=None, datas=datas, runtime_hooks=None, cipher=block_cipher) pyz = PYZ(a.pure, cipher=block_cipher) exe = EXE( pyz, a.scripts, a.binaries, a.zipfiles, a.datas, name=\u0026#39;bgmi\u0026#39;, debug=False, strip=None, upx=True, console=True, bootloader_ignore_signals=True, ) 其中，a = Analysis(['bgmi/__main__.py'],为程序的入口就是原本如果使用命令行的话，在 PyInstaller 后面跟的那个 py 文件路径。\n",
  "keywords": [
    "python"
  ],
  "articleBody": "那天突然好奇，docker-compose是用什么语言写的。然后一看，发现居然是用 python2 写的。\n但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用PyInstaller来进行打包的，把一个 python 应用打包成单个的二进制文件。\n一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。\n但用PyInstaller，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。\n首先，PyInstaller 的工作原理是从一个 py 文件出发在静态分析出所有用到的依赖，然后把所有的依赖打包起来，在用户使用二进制的时候释放到一个临时文件夹中，用 Python 解释器来运行。\nPyInstaller 入门的文章已经有很多了，就不再重复写一遍了，主要遇到的坑有这么几个。\n用到的非 py 文件要手动指定路径一起打包 我的程序中用到了一些模板文件，是在程序运行起来之后才根据需要加载决定是否渲染的。这些文件因为不是 python 文件，所以 PyInstaller 在分析的时候也不会知道是程序的一部分，就不会打包在二进制中。\n在程序运行的时候，如果用到了对应的文件，因为没有被打包进来的缘故，程序就会报错。\n如果用命令行来指定要一起打包的文件效率过低，所以可以编写一个 spec 文件来告诉 PyInstaller 要如何打包。\n（这是我之前尝试打包我的程序是用到的 spec 文件，但是因为不支持entry_points的原因，所以我最后放弃了使用这个办法，但是打包出来的程序在不用到entry_points的情况下是跟直接使用 pip 安装行为一致的。）\nbgmi.spec\n# -*- mode: python -*- from PyInstaller.building.api import EXE, PYZ from PyInstaller.building.build_main import Analysis import os import os.path import importlib bindata_dir = [ 'bgmi/front/templates', 'bgmi/lib/models/migrations', ] def get_bindata(): for dir_path in bindata_dir: for file in os.listdir(dir_path): yield (os.path.join(dir_path, file), dir_path) block_cipher = None package_imports = [['peewee_migrate', ['template.txt']]] datas = list(get_bindata()) for package, files in package_imports: proot = os.path.dirname(importlib.import_module(package).__file__) datas.extend((os.path.join(proot, f), package) for f in files) a = Analysis(['bgmi/__main__.py'], pathex=['.'], hiddenimports=[], hookspath=None, datas=datas, runtime_hooks=None, cipher=block_cipher) pyz = PYZ(a.pure, cipher=block_cipher) exe = EXE( pyz, a.scripts, a.binaries, a.zipfiles, a.datas, name='bgmi', debug=False, strip=None, upx=True, console=True, bootloader_ignore_signals=True, ) 其中，a = Analysis(['bgmi/__main__.py'],为程序的入口就是原本如果使用命令行的话，在 PyInstaller 后面跟的那个 py 文件路径。\n而get_bin_data则是找到所有要打包进去的非 py 文件，告诉 PyInstaller 这些文件需要打包。datas的格式应该是一个List[List]。而内部的列表第一个元素是文件的路径，第二个元素是文件要打包到的文件夹。\n比如说，如果要一起打包a/b/c.txt文件，datas中就应该添加一项[('a/b/c.txt', 'a/b'), ]，含义是告诉 PyInstaller 要把。/b/c.txt文件打包到a/b文件夹中，如果要打包整个文件夹，我不太确定能不能直接填写文件夹的路径，我是选择了用 python 列出文件夹内的所有文件，然后一股脑的添加到 datas 里面。\n而如果你用到的某个依赖（没错，在我这个例子里面就是peewee-migrate，他有一个template.txt文件，是在运行的时候动态读取的，同样需要添加到 datas 中。\n就是这段代码实现的功能\npackage_imports = [ ['peewee_migrate', ['template.txt']], ] datas = [] for package, files in package_imports: proot = os.path.dirname(importlib.import_module(package).__file__) datas.extend((os.path.join(proot, f), package) for f in files) 在package_imports中定义每个包需要额外引入的文件，在下面循环中找到所有需要打包的文件的路径，然后添加到 data 中去。\n支持 entry_point 这个支持 entry point 的意思不是说，我用来有一个用console_scripts做为入口的 python 程序如何用 pyinstaller 打包。\n而是说，如果你在entry_points里添加了其他的东西，比如说我的 python 程序中添加了这样的几个entry_points。\n[options.entry_points] bgmi.downloader.delegate = aria2-rpc = bgmi.downloader.aria2_rpc:Aria2DownloadRPC deluge-rpc = bgmi.downloader.deluge:DelugeRPC transmission-rpc = bgmi.downloader.transmissionRpc:TransmissionRPC 如果程序是通过pip install -e .安装到 python 环境中的，在运行程序的时候可以正常被load_entry_point加载。\n但如果是在 pyinstaller 打包出来的二进制中，默认程序是无法加载到任何entry_points的，因为PyInstaller默认只会打包所有的 py 文件，而一个包的entry_points的信息保存在package同级的目录package.egg-ino/entry_points.txt文件中，需要用之前提到的办法，把这个文件夹也打包进去，而且要跟package同级。这样在运行释放临时文件的时候，才能正常加载package对应的entry_points。\n",
  "wordCount" : "244",
  "inLanguage": "en",
  "datePublished": "2019-06-02T23:47:34+08:00",
  "dateModified": "2025-03-03T05:55:21+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.trim21.me/posts/build-python-package-with-pyinstaller/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Trim21's",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.trim21.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.trim21.me/" accesskey="h" title="Trim21&#39;s (Alt + H)">Trim21&#39;s</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.trim21.me/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      用PyInstaller打包python应用
    </h1>
    <div class="post-meta"><span title='2019-06-02 23:47:34 +0800 +0800'>2019-06-02</span>

</div>
  </header> 
  <div class="post-content"><p>那天突然好奇，<code>docker-compose</code>是用什么语言写的。然后一看，发现居然是用 python2 写的。</p>
<p>但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用<a href="https://github.com/pyinstaller/pyinstaller"><code>PyInstaller</code></a>来进行打包的，把一个 python 应用打包成单个的二进制文件。</p>
<p>一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。</p>
<p>但用<code>PyInstaller</code>，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。</p>
<p>首先，PyInstaller 的工作原理是从一个 py 文件出发在静态分析出所有用到的依赖，然后把所有的依赖打包起来，在用户使用二进制的时候释放到一个临时文件夹中，用 Python 解释器来运行。</p>
<p>PyInstaller 入门的文章已经有很多了，就不再重复写一遍了，主要遇到的坑有这么几个。</p>
<h2 id="用到的非-py-文件要手动指定路径一起打包">用到的非 py 文件要手动指定路径一起打包<a hidden class="anchor" aria-hidden="true" href="#用到的非-py-文件要手动指定路径一起打包">#</a></h2>
<p>我的程序中用到了一些模板文件，是在程序运行起来之后才根据需要加载决定是否渲染的。这些文件因为不是 python 文件，所以 PyInstaller 在分析的时候也不会知道是程序的一部分，就不会打包在二进制中。</p>
<p>在程序运行的时候，如果用到了对应的文件，因为没有被打包进来的缘故，程序就会报错。</p>
<p>如果用命令行来指定要一起打包的文件效率过低，所以可以编写一个 spec 文件来告诉 PyInstaller 要如何打包。</p>
<p>（这是我之前尝试打包我的程序是用到的 spec 文件，但是因为不支持<code>entry_points</code>的原因，所以我最后放弃了使用这个办法，但是打包出来的程序在不用到<code>entry_points</code>的情况下是跟直接使用 pip 安装行为一致的。）</p>
<p><code>bgmi.spec</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># -*- mode: python -*-</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> PyInstaller.building.api <span style="color:#f92672">import</span> EXE, PYZ
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> PyInstaller.building.build_main <span style="color:#f92672">import</span> Analysis
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os.path
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> importlib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bindata_dir <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;bgmi/front/templates&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;bgmi/lib/models/migrations&#39;</span>,
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_bindata</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> dir_path <span style="color:#f92672">in</span> bindata_dir:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> file <span style="color:#f92672">in</span> os<span style="color:#f92672">.</span>listdir(dir_path):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> (os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(dir_path, file), dir_path)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>block_cipher <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>package_imports <span style="color:#f92672">=</span> [[<span style="color:#e6db74">&#39;peewee_migrate&#39;</span>, [<span style="color:#e6db74">&#39;template.txt&#39;</span>]]]
</span></span><span style="display:flex;"><span>datas <span style="color:#f92672">=</span> list(get_bindata())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> package, files <span style="color:#f92672">in</span> package_imports:
</span></span><span style="display:flex;"><span>    proot <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>dirname(importlib<span style="color:#f92672">.</span>import_module(package)<span style="color:#f92672">.</span>__file__)
</span></span><span style="display:flex;"><span>    datas<span style="color:#f92672">.</span>extend((os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(proot, f), package) <span style="color:#66d9ef">for</span> f <span style="color:#f92672">in</span> files)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> Analysis([<span style="color:#e6db74">&#39;bgmi/__main__.py&#39;</span>],
</span></span><span style="display:flex;"><span>             pathex<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;.&#39;</span>],
</span></span><span style="display:flex;"><span>             hiddenimports<span style="color:#f92672">=</span>[],
</span></span><span style="display:flex;"><span>             hookspath<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>,
</span></span><span style="display:flex;"><span>             datas<span style="color:#f92672">=</span>datas,
</span></span><span style="display:flex;"><span>             runtime_hooks<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>,
</span></span><span style="display:flex;"><span>             cipher<span style="color:#f92672">=</span>block_cipher)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pyz <span style="color:#f92672">=</span> PYZ(a<span style="color:#f92672">.</span>pure, cipher<span style="color:#f92672">=</span>block_cipher)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>exe <span style="color:#f92672">=</span> EXE(
</span></span><span style="display:flex;"><span>    pyz,
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">.</span>scripts,
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">.</span>binaries,
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">.</span>zipfiles,
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">.</span>datas,
</span></span><span style="display:flex;"><span>    name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bgmi&#39;</span>,
</span></span><span style="display:flex;"><span>    debug<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>,
</span></span><span style="display:flex;"><span>    strip<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>,
</span></span><span style="display:flex;"><span>    upx<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>    console<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>    bootloader_ignore_signals<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>其中，<code>a = Analysis(['bgmi/__main__.py'],</code>为程序的入口就是原本如果使用命令行的话，在 PyInstaller 后面跟的那个 py 文件路径。</p>
<p>而<code>get_bin_data</code>则是找到所有要打包进去的非 py 文件，告诉 PyInstaller 这些文件需要打包。<code>datas</code>的格式应该是一个<code>List[List]</code>。而内部的列表第一个元素是文件的路径，第二个元素是文件要打包到的文件夹。</p>
<p>比如说，如果要一起打包<code>a/b/c.txt</code>文件，<code>datas</code>中就应该添加一项<code>[('a/b/c.txt', 'a/b'), ]</code>，含义是告诉 PyInstaller 要把<code>。/b/c.txt</code>文件打包到<code>a/b</code>文件夹中，如果要打包整个文件夹，我不太确定能不能直接填写文件夹的路径，我是选择了用 python 列出文件夹内的所有文件，然后一股脑的添加到 datas 里面。</p>
<p>而如果你用到的某个依赖（没错，在我这个例子里面就是<code>peewee-migrate</code>，他有一个<code>template.txt</code>文件，是在运行的时候动态读取的，同样需要添加到 datas 中。</p>
<p>就是这段代码实现的功能</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>package_imports <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#39;peewee_migrate&#39;</span>, [<span style="color:#e6db74">&#39;template.txt&#39;</span>]],
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>datas <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> package, files <span style="color:#f92672">in</span> package_imports:
</span></span><span style="display:flex;"><span>    proot <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>dirname(importlib<span style="color:#f92672">.</span>import_module(package)<span style="color:#f92672">.</span>__file__)
</span></span><span style="display:flex;"><span>    datas<span style="color:#f92672">.</span>extend((os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(proot, f), package) <span style="color:#66d9ef">for</span> f <span style="color:#f92672">in</span> files)
</span></span></code></pre></div><p>在<code>package_imports</code>中定义每个包需要额外引入的文件，在下面循环中找到所有需要打包的文件的路径，然后添加到 data 中去。</p>
<h2 id="支持-entry_point">支持 entry_point<a hidden class="anchor" aria-hidden="true" href="#支持-entry_point">#</a></h2>
<p>这个支持 entry point 的意思不是说，我用来有一个用<code>console_scripts</code>做为入口的 python 程序如何用 pyinstaller 打包。</p>
<p>而是说，如果你在<code>entry_points</code>里添加了其他的东西，比如说我的 python 程序中添加了这样的几个<code>entry_points</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#66d9ef">[options.entry_points]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bgmi.downloader.delegate</span> <span style="color:#f92672">=</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  aria2-rpc = bgmi.downloader.aria2_rpc:Aria2DownloadRPC
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  deluge-rpc = bgmi.downloader.deluge:DelugeRPC
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  transmission-rpc = bgmi.downloader.transmissionRpc:TransmissionRPC</span>
</span></span></code></pre></div><p>如果程序是通过<code>pip install -e .</code>安装到 python 环境中的，在运行程序的时候可以正常被<code>load_entry_point</code>加载。</p>
<p>但如果是在 pyinstaller 打包出来的二进制中，默认程序是无法加载到任何<code>entry_points</code>的，因为<code>PyInstaller</code>默认只会打包所有的 py 文件，而一个包的<code>entry_points</code>的信息保存在<code>package</code>同级的目录<code>package.egg-ino/entry_points.txt</code>文件中，需要用之前提到的办法，把这个文件夹也打包进去，而且要跟<code>package</code>同级。这样在运行释放临时文件的时候，才能正常加载<code>package</code>对应的<code>entry_points</code>。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.trim21.me/tags/python/">python</a></li>
    </ul>
  </footer><script src="https://utteranc.es/client.js"
    repo="trim21/blog"
    issue-term="title"
    theme="github-dark"
    crossorigin="anonymous"
    async></script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://blog.trim21.me/">Trim21&#39;s</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
