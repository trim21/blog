<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
            --font-size: 17.5px;
        }
    </style>

    
    
    
    
    
    

    
    <title>golang笔记</title>
    <meta name="description" content="一些约定 使用驼峰命名法 首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明) 数据类型 bool 布尔, true或者false
string 字符串, 使用双引号 比如&quot;hello world&quot; …">
    <meta name="keywords" content='golang'>

    <meta property="og:url" content="https://blog.trim21.me/posts/learning-golang/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="golang笔记">
    <meta property="og:description" content="一些约定 使用驼峰命名法 首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明) 数据类型 bool 布尔, true或者false
string 字符串, 使用双引号 比如&quot;hello world&quot; …">
    <meta property="og:image" content="https://blog.trim21.me/">
    <meta property="og:image:secure_url" content="https://blog.trim21.me/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="golang笔记">
    <meta name="twitter:description" content="一些约定 使用驼峰命名法 首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明) 数据类型 bool 布尔, true或者false
string 字符串, 使用双引号 比如&quot;hello world&quot; …">
    <meta property="twitter:domain" content="https://blog.trim21.me/posts/learning-golang/">
    <meta property="twitter:url" content="https://blog.trim21.me/posts/learning-golang/">
    <meta name="twitter:image" content="https://blog.trim21.me/">

    
    <link rel="canonical" href="https://blog.trim21.me/posts/learning-golang/">

    
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">

    
    <script src="/js/bundle.min.275fedb6f364c8865658bae576d82b514ace973f6a13ed63503a85b20c697453.js" integrity="sha256-J1/ttvNkyIZWWLrldtgrUUrOlz9qE&#43;1jUDqFsgxpdFM="></script>

    
    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        

        <div class="nav-title">
            <a class="nav-brand" href="https://blog.trim21.me/">Trim21&#39;s Blog</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://blog.trim21.me/posts/" aria-label="" > Blog </a>
            </div>
            
            <div class="nav-link">
                <a href="https://blog.trim21.me/about/" aria-label="" > About </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                <a aria-hidden="true" role="switch">
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a aria-checked="false" aria-labelledby="hamburger-menu-toggle" id="hamburger-menu-toggle-target" role="switch">
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://blog.trim21.me/posts/" > Blog </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://blog.trim21.me/about/" > About </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a role="switch">
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>golang笔记</h1>

        

        
	
	
	
	
        

	

	

	
          <small role="doc-subtitle"></small>
	

	
          <p class="post-date">
              

              November 1, 2018

              
          </p>
	

        <ul class="post-tags">
          
           
             <li class="post-tag"><a href="https://blog.trim21.me/tags/golang">golang</a></li>
           
         
        </ul>
    </div>

    <div class="post-content">
        <h2 id="一些约定">一些约定</h2>
<ol>
<li>使用驼峰命名法</li>
<li>首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)</li>
</ol>
<h2 id="数据类型">数据类型</h2>
<h3 id="bool">bool</h3>
<p>布尔, <code>true</code>或者<code>false</code></p>
<h3 id="string">string</h3>
<p>字符串, 使用双引号 比如<code>&quot;hello world&quot;</code></p>
<h3 id="rune">rune</h3>
<p>类似于字符, 在使用<code>for _, char := range string</code>迭代 string 的时候, char 的类型就是 rune</p>
<h3 id="int">int</h3>
<p>未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用<code>int()</code>转化为 int</p>
<h3 id="byte">byte</h3>
<p><code>[]byte</code>可以跟 string 互相转化, <code>len(string)</code>的长度实际上就是 string 转化为<code>[]byte</code>之后的长度. 每个 unicode 的长度为 3. 比如说<code>len(&quot;hello world&quot;)==11</code>, 但是<code>len(&quot;你好 世界&quot;)</code>的长度为 3+3+1=7. 每个汉字因为是 unicode 所以为 3.</p>
<h3 id="指针">指针</h3>
<p>可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)</p>
<h3 id="数组">数组</h3>
<p>用于存放类型相同的一组数据.</p>
<h4 id="slice">slice</h4>
<p>可变长度</p>
<h4 id="array">array</h4>
<p>长度不可变</p>
<h3 id="map">map</h3>
<p>类似于 python 中的 dict, 但是需要指定 key 和 value 的类型</p>
<p>比如 python 中的<code>Map[str, str]</code>在 golang 中为<code>map[string]string</code>, 这个 map 只能以 string 为 key, 以 string 为 value.</p>
<p>如果要一个可以存储任意数据类型的 map 可以<code>map[string]interface{}</code></p>
<h3 id="函数">函数</h3>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">main</span>(arg1 argType1, arg2 argType2) (returnType1, returnType2){
</span></span><span style="display:flex;"><span>    main body
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>golang 中, 变量的类型是放在变量名之后的.</p>
<h3 id="struct">struct</h3>
<p>结构体, 类似于 python 中的 class.</p>
<h4 id="定义">定义</h4>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Episode <span style="color:#ff7b72">struct</span> {
</span></span><span style="display:flex;"><span>    Title   <span style="color:#ff7b72">string</span>
</span></span><span style="display:flex;"><span>    Torrent <span style="color:#ff7b72">string</span>
</span></span><span style="display:flex;"><span>    Episode <span style="color:#ff7b72">int</span>
</span></span><span style="display:flex;"><span>    Time    <span style="color:#ff7b72">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="初始化">初始化</h4>
<p>使用大括号</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff7b72">var</span> e = Episode{
</span></span><span style="display:flex;"><span>    Title:   <span style="color:#a5d6ff">&#34;hello world&#34;</span>,
</span></span><span style="display:flex;"><span>    Episode: <span style="color:#a5d6ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="结构体的方法">结构体的方法</h4>
<p>如果要在其上绑定函数, 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (episode <span style="color:#ff7b72;font-weight:bold">*</span>Episode) <span style="color:#d2a8ff;font-weight:bold">getTitle</span>() <span style="color:#ff7b72">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">return</span> episode.Title
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>条用跟其他语言的调用方法类似.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>e.<span style="color:#d2a8ff;font-weight:bold">getTitle</span>()
</span></span></code></pre></div><h3 id="接口-interface">接口 interface</h3>
<p>还没有实际用到, 所以只有一些粗浅的理解.</p>
<p>interface 接口是为了面向对象而出现的, 一个函数可以参数可以为一系列不特定的类型, 但无所谓具体的类型, 只要这个类型实现了特定的方法即可.</p>
<p>比如一个<code>writeTo</code>函数接受一个<code>io.Writer</code>的参数</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">writeTo</span>(w io.Writer) <span style="color:#ff7b72">error</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// io.Writer</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Writer <span style="color:#ff7b72">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#d2a8ff;font-weight:bold">Write</span>(p []<span style="color:#ff7b72">byte</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>只要是实现了<code>Write</code>方法的, 输入值和返回值匹配<code>([]byte) (int, error)</code>类型都可以做为这个函数的参数. 比如说默认的标准库<code>os</code>提供的<code>os.Stdout</code>就是一个实现了<code>io.Writer</code>接口的类型. 比如说, 这里就可以以<code>writeTo(os.Stdout)</code>的形式调用.</p>
<h3 id="channel">channel</h3>
<p>信道</p>
<p>go 并发中, 不同<code>goroutine</code>的通信工具.</p>
<p>无缓冲区或者缓冲区已满的情况下进行写入是阻塞的.</p>
<p>如果信道为空, 而试图读取也会阻塞.</p>
<p>只有读取没有写入或者只有写入没有读取会导致死锁.</p>
<h2 id="并发编程">并发编程</h2>
<p>golang 提供了<code>go</code>关键词来开启一个<code>goroutine</code>.</p>
<p>因为 goroutine 函数的返回值是会被丢弃的, 使用回调函数的话又会陷入回调地域中, 所以需要一种额外的方式来接受异步函数的返回结果.</p>
<p>这里就要贴出那句 go 并发文章常常能看到的话了</p>
<blockquote>
<p>不要通过共享内存来通信，而应该通过通信来共享内存</p></blockquote>
<p>而<code>channel</code>, 就是 go 提供的通信的工具. 可以在一个线程中发送数据, 在另一个线程中接收数据. 如果我们要写一个异步爬虫, 就可以开四个线程来爬取数据, 在爬到数据后通过 channel 发送到主线程, 然后在主线程中使用 channel 接受, 交给 pipeline 来处理.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff7b72">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a5d6ff">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">costumer</span>(c <span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">for</span> each <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72">range</span> c {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#d2a8ff;font-weight:bold">Printf</span>(<span style="color:#a5d6ff">&#34;costume %d\n&#34;</span>, each)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#d2a8ff;font-weight:bold">Println</span>(<span style="color:#a5d6ff">&#34;hello world&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">var</span> c = make(<span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">go</span> <span style="color:#d2a8ff;font-weight:bold">costumer</span>(c)
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">for</span> index <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#a5d6ff">0</span>; index &lt; <span style="color:#a5d6ff">5</span>; index<span style="color:#ff7b72;font-weight:bold">++</span> {
</span></span><span style="display:flex;"><span>        c <span style="color:#ff7b72;font-weight:bold">&lt;-</span> index
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用<code>go costumer(channel)</code>启动了一个新的消费者线程, 而主线程自己也是一个<code>goroutine</code>, 虽然跟<code>costumer</code>不在同一个线程中, 但是仍然可以通过 channel 通信, 在这里, 主线程就是生产者, 消费者模型中的生产者.</p>
<h3 id="并发控制">并发控制</h3>
<p>有时候并不需要很大的并发量, 比如我们只想起 4 个或者 8 个生产者, 可以使用<code>sync.WaitGroup</code>来进行并发控制.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff7b72">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a5d6ff">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a5d6ff">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">var</span> controller = <span style="color:#d2a8ff;font-weight:bold">newController</span>(<span style="color:#a5d6ff">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">var</span> urls = []<span style="color:#ff7b72">string</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">for</span> index <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#a5d6ff">0</span>; index &lt; <span style="color:#a5d6ff">20</span>; index<span style="color:#ff7b72;font-weight:bold">++</span> {
</span></span><span style="display:flex;"><span>        urls = append(urls, fmt.<span style="color:#d2a8ff;font-weight:bold">Sprintf</span>(<span style="color:#a5d6ff">&#34;%d&#34;</span>, index))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">go</span> controller.<span style="color:#d2a8ff;font-weight:bold">dispatchGocoutine</span>(urls)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">for</span> each <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72">range</span> controller.output {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#d2a8ff;font-weight:bold">Println</span>(<span style="color:#a5d6ff">&#34;collect output &#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span> each)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> asyncControl <span style="color:#ff7b72">struct</span> {
</span></span><span style="display:flex;"><span>    wrg       sync.WaitGroup
</span></span><span style="display:flex;"><span>    output     <span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">string</span>
</span></span><span style="display:flex;"><span>    goroutineCnt <span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// newController</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">newController</span>(size <span style="color:#ff7b72">int</span>) <span style="color:#ff7b72;font-weight:bold">*</span>asyncControl {
</span></span><span style="display:flex;"><span>    d <span style="color:#ff7b72;font-weight:bold">:=</span> new(asyncControl)
</span></span><span style="display:flex;"><span>    d.wrg = sync.WaitGroup{}
</span></span><span style="display:flex;"><span>    d.output = make(<span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">string</span>)
</span></span><span style="display:flex;"><span>    d.goroutineCnt = make(<span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">int</span>, size)
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">return</span> d
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (controller <span style="color:#ff7b72;font-weight:bold">*</span>asyncControl) <span style="color:#d2a8ff;font-weight:bold">dispatchGocoutine</span>(urls []<span style="color:#ff7b72">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">for</span> _, url <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72">range</span> urls {
</span></span><span style="display:flex;"><span>        controller.goroutineCnt <span style="color:#ff7b72;font-weight:bold">&lt;-</span> <span style="color:#a5d6ff">0</span> <span style="color:#8b949e;font-style:italic">// 限制线程数</span>
</span></span><span style="display:flex;"><span>        controller.wrg.<span style="color:#d2a8ff;font-weight:bold">Add</span>(<span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">go</span> controller.<span style="color:#d2a8ff;font-weight:bold">asyncTask</span>(url)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    controller.wrg.<span style="color:#d2a8ff;font-weight:bold">Wait</span>() <span style="color:#8b949e;font-style:italic">// 等待至所有分发出去的线程结束</span>
</span></span><span style="display:flex;"><span>    close(controller.output)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (controller <span style="color:#ff7b72;font-weight:bold">*</span>asyncControl) <span style="color:#d2a8ff;font-weight:bold">asyncTask</span>(url <span style="color:#ff7b72">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">defer</span> <span style="color:#ff7b72">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72;font-weight:bold">&lt;-</span>controller.goroutineCnt
</span></span><span style="display:flex;"><span>        controller.wrg.<span style="color:#d2a8ff;font-weight:bold">Done</span>()
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#8b949e;font-style:italic">// some task here</span>
</span></span><span style="display:flex;"><span>    controller.output <span style="color:#ff7b72;font-weight:bold">&lt;-</span> <span style="color:#a5d6ff">&#34;processed &#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span> url
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为提到在缓冲区已满的情况下写入是阻塞的, 所以可以利用这一点来进行并发控制. <code>goroutineCnt</code>就是用来控制最大线程数的任务. 当我们试图开启一个新的线程的时候, 先向<code>goroutineCnt</code>中进行一次写入, 再开启一个新的任务. 而在工作进程中, 在整个函数执行完成后则从<code>goroutineCnt</code>中进行一次读取. 缓冲区就会空出一位来, 而进行工作分发的线程的阻塞此时就结束了, 在成功写入信道之后则会开启一个新的线程. 保持工作线程数量永远不会超过<code>goroutineCnt</code>的缓冲区长度.</p>
<p>这个<code>sync.WaitGroup</code>是另一个并发的工具, 因为不能确定其他 goroutine 什么时候才能结束, 所以使用<code>wrk.Wait()</code>来在分发结束后阻塞分发的线程, 在所有分发出去的线程结束后关闭信道.</p>

        
        <div class="post-comments">
            <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "trim21" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>
        
    </div>

    <div class="prev-next">
        
    </div>

    
    
    
</div>



    

        </main><footer class="footer">
    
    

    

    

    

    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/gokarna-theme/gokarna-hugo">Gokarna</a>
    </span>
</footer>
</body>
</html>
