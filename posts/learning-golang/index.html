<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>golang笔记 | Trim21&#39;s</title>
<meta name="keywords" content="golang">
<meta name="description" content="一些约定

使用驼峰命名法
首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)

数据类型
bool
布尔, true或者false
string
字符串, 使用双引号 比如&quot;hello world&quot;
rune
类似于字符, 在使用for _, char := range string迭代 string 的时候, char 的类型就是 rune
int
未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用int()转化为 int
byte
[]byte可以跟 string 互相转化, len(string)的长度实际上就是 string 转化为[]byte之后的长度. 每个 unicode 的长度为 3. 比如说len(&quot;hello world&quot;)==11, 但是len(&quot;你好 世界&quot;)的长度为 3&#43;3&#43;1=7. 每个汉字因为是 unicode 所以为 3.
指针
可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)
数组
用于存放类型相同的一组数据.
slice
可变长度">
<meta name="author" content="">
<link rel="canonical" href="https://blog.trim21.me/posts/learning-golang/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.trim21.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.trim21.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.trim21.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.trim21.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.trim21.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.trim21.me/posts/learning-golang/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.trim21.me/posts/learning-golang/">
  <meta property="og:site_name" content="Trim21&#39;s">
  <meta property="og:title" content="golang笔记">
  <meta property="og:description" content="一些约定 使用驼峰命名法 首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明) 数据类型 bool 布尔, true或者false
string 字符串, 使用双引号 比如&#34;hello world&#34;
rune 类似于字符, 在使用for _, char := range string迭代 string 的时候, char 的类型就是 rune
int 未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用int()转化为 int
byte []byte可以跟 string 互相转化, len(string)的长度实际上就是 string 转化为[]byte之后的长度. 每个 unicode 的长度为 3. 比如说len(&#34;hello world&#34;)==11, 但是len(&#34;你好 世界&#34;)的长度为 3&#43;3&#43;1=7. 每个汉字因为是 unicode 所以为 3.
指针 可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)
数组 用于存放类型相同的一组数据.
slice 可变长度">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-11-01T17:25:15+08:00">
    <meta property="article:modified_time" content="2025-03-03T05:55:21+08:00">
    <meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="golang笔记">
<meta name="twitter:description" content="一些约定

使用驼峰命名法
首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)

数据类型
bool
布尔, true或者false
string
字符串, 使用双引号 比如&quot;hello world&quot;
rune
类似于字符, 在使用for _, char := range string迭代 string 的时候, char 的类型就是 rune
int
未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用int()转化为 int
byte
[]byte可以跟 string 互相转化, len(string)的长度实际上就是 string 转化为[]byte之后的长度. 每个 unicode 的长度为 3. 比如说len(&quot;hello world&quot;)==11, 但是len(&quot;你好 世界&quot;)的长度为 3&#43;3&#43;1=7. 每个汉字因为是 unicode 所以为 3.
指针
可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)
数组
用于存放类型相同的一组数据.
slice
可变长度">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "posts",
      "item": "https://blog.trim21.me/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "golang笔记",
      "item": "https://blog.trim21.me/posts/learning-golang/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "golang笔记",
  "name": "golang笔记",
  "description": "一些约定 使用驼峰命名法 首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明) 数据类型 bool 布尔, true或者false\nstring 字符串, 使用双引号 比如\u0026quot;hello world\u0026quot;\nrune 类似于字符, 在使用for _, char := range string迭代 string 的时候, char 的类型就是 rune\nint 未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用int()转化为 int\nbyte []byte可以跟 string 互相转化, len(string)的长度实际上就是 string 转化为[]byte之后的长度. 每个 unicode 的长度为 3. 比如说len(\u0026quot;hello world\u0026quot;)==11, 但是len(\u0026quot;你好 世界\u0026quot;)的长度为 3+3+1=7. 每个汉字因为是 unicode 所以为 3.\n指针 可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)\n数组 用于存放类型相同的一组数据.\nslice 可变长度\n",
  "keywords": [
    "golang"
  ],
  "articleBody": "一些约定 使用驼峰命名法 首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明) 数据类型 bool 布尔, true或者false\nstring 字符串, 使用双引号 比如\"hello world\"\nrune 类似于字符, 在使用for _, char := range string迭代 string 的时候, char 的类型就是 rune\nint 未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用int()转化为 int\nbyte []byte可以跟 string 互相转化, len(string)的长度实际上就是 string 转化为[]byte之后的长度. 每个 unicode 的长度为 3. 比如说len(\"hello world\")==11, 但是len(\"你好 世界\")的长度为 3+3+1=7. 每个汉字因为是 unicode 所以为 3.\n指针 可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)\n数组 用于存放类型相同的一组数据.\nslice 可变长度\narray 长度不可变\nmap 类似于 python 中的 dict, 但是需要指定 key 和 value 的类型\n比如 python 中的Map[str, str]在 golang 中为map[string]string, 这个 map 只能以 string 为 key, 以 string 为 value.\n如果要一个可以存储任意数据类型的 map 可以map[string]interface{}\n函数 func main(arg1 argType1, arg2 argType2) (returnType1, returnType2){ main body } golang 中, 变量的类型是放在变量名之后的.\nstruct 结构体, 类似于 python 中的 class.\n定义 type Episode struct { Title string Torrent string Episode int Time int } 初始化 使用大括号\nvar e = Episode{ Title: \"hello world\", Episode: 1, } 结构体的方法 如果要在其上绑定函数, 使用\nfunc (episode *Episode) getTitle() string { return episode.Title } 条用跟其他语言的调用方法类似.\ne.getTitle() 接口 interface 还没有实际用到, 所以只有一些粗浅的理解.\ninterface 接口是为了面向对象而出现的, 一个函数可以参数可以为一系列不特定的类型, 但无所谓具体的类型, 只要这个类型实现了特定的方法即可.\n比如一个writeTo函数接受一个io.Writer的参数\nfunc writeTo(w io.Writer) error { } // io.Writer type Writer interface { Write(p []byte) (n int, err error) } 只要是实现了Write方法的, 输入值和返回值匹配([]byte) (int, error)类型都可以做为这个函数的参数. 比如说默认的标准库os提供的os.Stdout就是一个实现了io.Writer接口的类型. 比如说, 这里就可以以writeTo(os.Stdout)的形式调用.\nchannel 信道\ngo 并发中, 不同goroutine的通信工具.\n无缓冲区或者缓冲区已满的情况下进行写入是阻塞的.\n如果信道为空, 而试图读取也会阻塞.\n只有读取没有写入或者只有写入没有读取会导致死锁.\n并发编程 golang 提供了go关键词来开启一个goroutine.\n因为 goroutine 函数的返回值是会被丢弃的, 使用回调函数的话又会陷入回调地域中, 所以需要一种额外的方式来接受异步函数的返回结果.\n这里就要贴出那句 go 并发文章常常能看到的话了\n不要通过共享内存来通信，而应该通过通信来共享内存\n而channel, 就是 go 提供的通信的工具. 可以在一个线程中发送数据, 在另一个线程中接收数据. 如果我们要写一个异步爬虫, 就可以开四个线程来爬取数据, 在爬到数据后通过 channel 发送到主线程, 然后在主线程中使用 channel 接受, 交给 pipeline 来处理.\npackage main import ( \"fmt\" ) func costumer(c chan int) { for each := range c { fmt.Printf(\"costume %d\\n\", each) } } func main() { fmt.Println(\"hello world\") var c = make(chan int) go costumer(c) for index := 0; index \u003c 5; index++ { c \u003c- index } } 使用go costumer(channel)启动了一个新的消费者线程, 而主线程自己也是一个goroutine, 虽然跟costumer不在同一个线程中, 但是仍然可以通过 channel 通信, 在这里, 主线程就是生产者, 消费者模型中的生产者.\n并发控制 有时候并不需要很大的并发量, 比如我们只想起 4 个或者 8 个生产者, 可以使用sync.WaitGroup来进行并发控制.\npackage main import ( \"fmt\" \"sync\" ) func main() { var controller = newController(4) var urls = []string{} for index := 0; index \u003c 20; index++ { urls = append(urls, fmt.Sprintf(\"%d\", index)) } go controller.dispatchGocoutine(urls) for each := range controller.output { fmt.Println(\"collect output \" + each) } } type asyncControl struct { wrg sync.WaitGroup output chan string goroutineCnt chan int } // newController func newController(size int) *asyncControl { d := new(asyncControl) d.wrg = sync.WaitGroup{} d.output = make(chan string) d.goroutineCnt = make(chan int, size) return d } func (controller *asyncControl) dispatchGocoutine(urls []string) { for _, url := range urls { controller.goroutineCnt \u003c- 0 // 限制线程数 controller.wrg.Add(1) go controller.asyncTask(url) } controller.wrg.Wait() // 等待至所有分发出去的线程结束 close(controller.output) } func (controller *asyncControl) asyncTask(url string) { defer func() { \u003c-controller.goroutineCnt controller.wrg.Done() }() // some task here controller.output \u003c- \"processed \" + url } 因为提到在缓冲区已满的情况下写入是阻塞的, 所以可以利用这一点来进行并发控制. goroutineCnt就是用来控制最大线程数的任务. 当我们试图开启一个新的线程的时候, 先向goroutineCnt中进行一次写入, 再开启一个新的任务. 而在工作进程中, 在整个函数执行完成后则从goroutineCnt中进行一次读取. 缓冲区就会空出一位来, 而进行工作分发的线程的阻塞此时就结束了, 在成功写入信道之后则会开启一个新的线程. 保持工作线程数量永远不会超过goroutineCnt的缓冲区长度.\n这个sync.WaitGroup是另一个并发的工具, 因为不能确定其他 goroutine 什么时候才能结束, 所以使用wrk.Wait()来在分发结束后阻塞分发的线程, 在所有分发出去的线程结束后关闭信道.\n",
  "wordCount" : "455",
  "inLanguage": "en",
  "datePublished": "2018-11-01T17:25:15+08:00",
  "dateModified": "2025-03-03T05:55:21+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.trim21.me/posts/learning-golang/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Trim21's",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.trim21.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.trim21.me/" accesskey="h" title="Trim21&#39;s (Alt + H)">Trim21&#39;s</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.trim21.me/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      golang笔记
    </h1>
    <div class="post-meta"><span title='2018-11-01 17:25:15 +0800 +0800'>2018-11-01</span>

</div>
  </header> 
  <div class="post-content"><h2 id="一些约定">一些约定<a hidden class="anchor" aria-hidden="true" href="#一些约定">#</a></h2>
<ol>
<li>使用驼峰命名法</li>
<li>首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)</li>
</ol>
<h2 id="数据类型">数据类型<a hidden class="anchor" aria-hidden="true" href="#数据类型">#</a></h2>
<h3 id="bool">bool<a hidden class="anchor" aria-hidden="true" href="#bool">#</a></h3>
<p>布尔, <code>true</code>或者<code>false</code></p>
<h3 id="string">string<a hidden class="anchor" aria-hidden="true" href="#string">#</a></h3>
<p>字符串, 使用双引号 比如<code>&quot;hello world&quot;</code></p>
<h3 id="rune">rune<a hidden class="anchor" aria-hidden="true" href="#rune">#</a></h3>
<p>类似于字符, 在使用<code>for _, char := range string</code>迭代 string 的时候, char 的类型就是 rune</p>
<h3 id="int">int<a hidden class="anchor" aria-hidden="true" href="#int">#</a></h3>
<p>未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用<code>int()</code>转化为 int</p>
<h3 id="byte">byte<a hidden class="anchor" aria-hidden="true" href="#byte">#</a></h3>
<p><code>[]byte</code>可以跟 string 互相转化, <code>len(string)</code>的长度实际上就是 string 转化为<code>[]byte</code>之后的长度. 每个 unicode 的长度为 3. 比如说<code>len(&quot;hello world&quot;)==11</code>, 但是<code>len(&quot;你好 世界&quot;)</code>的长度为 3+3+1=7. 每个汉字因为是 unicode 所以为 3.</p>
<h3 id="指针">指针<a hidden class="anchor" aria-hidden="true" href="#指针">#</a></h3>
<p>可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)</p>
<h3 id="数组">数组<a hidden class="anchor" aria-hidden="true" href="#数组">#</a></h3>
<p>用于存放类型相同的一组数据.</p>
<h4 id="slice">slice<a hidden class="anchor" aria-hidden="true" href="#slice">#</a></h4>
<p>可变长度</p>
<h4 id="array">array<a hidden class="anchor" aria-hidden="true" href="#array">#</a></h4>
<p>长度不可变</p>
<h3 id="map">map<a hidden class="anchor" aria-hidden="true" href="#map">#</a></h3>
<p>类似于 python 中的 dict, 但是需要指定 key 和 value 的类型</p>
<p>比如 python 中的<code>Map[str, str]</code>在 golang 中为<code>map[string]string</code>, 这个 map 只能以 string 为 key, 以 string 为 value.</p>
<p>如果要一个可以存储任意数据类型的 map 可以<code>map[string]interface{}</code></p>
<h3 id="函数">函数<a hidden class="anchor" aria-hidden="true" href="#函数">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(<span style="color:#a6e22e">arg1</span> <span style="color:#a6e22e">argType1</span>, <span style="color:#a6e22e">arg2</span> <span style="color:#a6e22e">argType2</span>) (<span style="color:#a6e22e">returnType1</span>, <span style="color:#a6e22e">returnType2</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">main</span> <span style="color:#a6e22e">body</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>golang 中, 变量的类型是放在变量名之后的.</p>
<h3 id="struct">struct<a hidden class="anchor" aria-hidden="true" href="#struct">#</a></h3>
<p>结构体, 类似于 python 中的 class.</p>
<h4 id="定义">定义<a hidden class="anchor" aria-hidden="true" href="#定义">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Episode</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Title</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Torrent</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Episode</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Time</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="初始化">初始化<a hidden class="anchor" aria-hidden="true" href="#初始化">#</a></h4>
<p>使用大括号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">e</span> = <span style="color:#a6e22e">Episode</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Title</span>:   <span style="color:#e6db74">&#34;hello world&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Episode</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="结构体的方法">结构体的方法<a hidden class="anchor" aria-hidden="true" href="#结构体的方法">#</a></h4>
<p>如果要在其上绑定函数, 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">episode</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Episode</span>) <span style="color:#a6e22e">getTitle</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">episode</span>.<span style="color:#a6e22e">Title</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>条用跟其他语言的调用方法类似.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">getTitle</span>()
</span></span></code></pre></div><h3 id="接口-interface">接口 interface<a hidden class="anchor" aria-hidden="true" href="#接口-interface">#</a></h3>
<p>还没有实际用到, 所以只有一些粗浅的理解.</p>
<p>interface 接口是为了面向对象而出现的, 一个函数可以参数可以为一系列不特定的类型, 但无所谓具体的类型, 只要这个类型实现了特定的方法即可.</p>
<p>比如一个<code>writeTo</code>函数接受一个<code>io.Writer</code>的参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">writeTo</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#75715e">// io.Writer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>只要是实现了<code>Write</code>方法的, 输入值和返回值匹配<code>([]byte) (int, error)</code>类型都可以做为这个函数的参数. 比如说默认的标准库<code>os</code>提供的<code>os.Stdout</code>就是一个实现了<code>io.Writer</code>接口的类型. 比如说, 这里就可以以<code>writeTo(os.Stdout)</code>的形式调用.</p>
<h3 id="channel">channel<a hidden class="anchor" aria-hidden="true" href="#channel">#</a></h3>
<p>信道</p>
<p>go 并发中, 不同<code>goroutine</code>的通信工具.</p>
<p>无缓冲区或者缓冲区已满的情况下进行写入是阻塞的.</p>
<p>如果信道为空, 而试图读取也会阻塞.</p>
<p>只有读取没有写入或者只有写入没有读取会导致死锁.</p>
<h2 id="并发编程">并发编程<a hidden class="anchor" aria-hidden="true" href="#并发编程">#</a></h2>
<p>golang 提供了<code>go</code>关键词来开启一个<code>goroutine</code>.</p>
<p>因为 goroutine 函数的返回值是会被丢弃的, 使用回调函数的话又会陷入回调地域中, 所以需要一种额外的方式来接受异步函数的返回结果.</p>
<p>这里就要贴出那句 go 并发文章常常能看到的话了</p>
<blockquote>
<p>不要通过共享内存来通信，而应该通过通信来共享内存</p></blockquote>
<p>而<code>channel</code>, 就是 go 提供的通信的工具. 可以在一个线程中发送数据, 在另一个线程中接收数据. 如果我们要写一个异步爬虫, 就可以开四个线程来爬取数据, 在爬到数据后通过 channel 发送到主线程, 然后在主线程中使用 channel 接受, 交给 pipeline 来处理.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">costumer</span>(<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">each</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;costume %d\n&#34;</span>, <span style="color:#a6e22e">each</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;hello world&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">costumer</span>(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">index</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">index</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用<code>go costumer(channel)</code>启动了一个新的消费者线程, 而主线程自己也是一个<code>goroutine</code>, 虽然跟<code>costumer</code>不在同一个线程中, 但是仍然可以通过 channel 通信, 在这里, 主线程就是生产者, 消费者模型中的生产者.</p>
<h3 id="并发控制">并发控制<a hidden class="anchor" aria-hidden="true" href="#并发控制">#</a></h3>
<p>有时候并不需要很大的并发量, 比如我们只想起 4 个或者 8 个生产者, 可以使用<code>sync.WaitGroup</code>来进行并发控制.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">controller</span> = <span style="color:#a6e22e">newController</span>(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">urls</span> = []<span style="color:#66d9ef">string</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">index</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">urls</span> = append(<span style="color:#a6e22e">urls</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#a6e22e">index</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">dispatchGocoutine</span>(<span style="color:#a6e22e">urls</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">each</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">output</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;collect output &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">each</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">asyncControl</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wrg</span>       <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">output</span>     <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">goroutineCnt</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// newController</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newController</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">asyncControl</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">asyncControl</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">wrg</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">output</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">goroutineCnt</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">controller</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">asyncControl</span>) <span style="color:#a6e22e">dispatchGocoutine</span>(<span style="color:#a6e22e">urls</span> []<span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">url</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">urls</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">goroutineCnt</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">// 限制线程数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">wrg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">asyncTask</span>(<span style="color:#a6e22e">url</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">wrg</span>.<span style="color:#a6e22e">Wait</span>() <span style="color:#75715e">// 等待至所有分发出去的线程结束</span>
</span></span><span style="display:flex;"><span>    close(<span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">output</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">controller</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">asyncControl</span>) <span style="color:#a6e22e">asyncTask</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">goroutineCnt</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">wrg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// some task here</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">output</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;processed &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">url</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为提到在缓冲区已满的情况下写入是阻塞的, 所以可以利用这一点来进行并发控制. <code>goroutineCnt</code>就是用来控制最大线程数的任务. 当我们试图开启一个新的线程的时候, 先向<code>goroutineCnt</code>中进行一次写入, 再开启一个新的任务. 而在工作进程中, 在整个函数执行完成后则从<code>goroutineCnt</code>中进行一次读取. 缓冲区就会空出一位来, 而进行工作分发的线程的阻塞此时就结束了, 在成功写入信道之后则会开启一个新的线程. 保持工作线程数量永远不会超过<code>goroutineCnt</code>的缓冲区长度.</p>
<p>这个<code>sync.WaitGroup</code>是另一个并发的工具, 因为不能确定其他 goroutine 什么时候才能结束, 所以使用<code>wrk.Wait()</code>来在分发结束后阻塞分发的线程, 在所有分发出去的线程结束后关闭信道.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.trim21.me/tags/golang/">golang</a></li>
    </ul>
  </footer><script src="https://utteranc.es/client.js"
    repo="trim21/blog"
    issue-term="title"
    theme="github-dark"
    crossorigin="anonymous"
    async></script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://blog.trim21.me/">Trim21&#39;s</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
