<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Trim21&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ecf2f0caf1431530291fbea8e3f1636c</icon>
  
  <link href="https://blog.trim21.me/feed.xml" rel="self"/>
  
  <link href="https://blog.trim21.me/"/>
  <updated>2019-12-22T16:00:00.000Z</updated>
  <id>https://blog.trim21.me/</id>
  
  <author>
    <name>Trim21</name>
    <email>trim21.me@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>caddy在内网中无法更新证书</title>
    <link href="https://blog.trim21.me/2019/12/caddy-not-working-in-nat.html"/>
    <id>https://blog.trim21.me/2019/12/caddy-not-working-in-nat.html</id>
    <published>2019-12-23T07:31:10.000Z</published>
    <updated>2019-12-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>NAS 上面运行了一个 caddy 服务器，还设置了 https。最近突然遇到了证书过期的问题.</p><p>检查 log 发现是证书申请失败 <code>SERVFAIL for _acme-challenge.my_domain.</code></p><p>大概搜索了一下, 是因为路由器的 dnsmasq 过滤掉了完成验证需要的 dns 查询</p><p>只要在 dnsmasq 设置中把 filterwin2k 参数禁用即可, 不同版本的 dnsmasq 禁用方法有些不同</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;NAS 上面运行了一个 caddy 服务器，还设置了 https。最近突然遇到了证书过期的问题.&lt;/p&gt;
&lt;p&gt;检查 log 发现是证书申请失败 &lt;code&gt;SERVFAIL for _acme-challenge.my_domain.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大概搜索</summary>
      
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="https" scheme="https://blog.trim21.me/tag/https/"/>
    
  </entry>
  
  <entry>
    <title>利用手头已有资源尽可能高配的搭一台nas</title>
    <link href="https://blog.trim21.me/2019/12/build-a-nas.html"/>
    <id>https://blog.trim21.me/2019/12/build-a-nas.html</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>现成已有的 nas：一台蜗牛星际 B 口单百兆，现在放了四块 500G 的硬盘租了一个 raid6。除去硬盘成本 268（机器）+200（电源）, 硬盘是旧硬盘. 用了三四个月之后已经有三四块硬盘报警了.</p><p>总是觉得有些不爽，主要是又不想把现有 nas 里面的数据都拷出来换硬盘，又觉得现在的百兆和 1T 容量不太能让人满意，所以想搞一个千兆的高性能 nas。</p><p>看了看市面上 nas 的价格，感觉硬件配置又不太对的起价格，于是决定自己搞一个。正好自己现在还闲置着一台核显的 itx 小机器</p><span id="more"></span><h2 id="手头硬件">手头硬件</h2><h3 id="CPU-和主板">CPU 和主板</h3><ol><li>四代 i3 主板 4 个 sata3, 一个 m2 接口, 一个 pci-e 16x 接口, 两个 ddr4 内存接口</li><li>J1900, 主板两个 sata2 接口, 两个 ddr3 内存接口.</li></ol><h3 id="内存">内存</h3><p>两条 4g 台式机 ddr4 内存</p><p>一条 ddr3 内存接口</p><h3 id="硬盘">硬盘</h3><ol><li>闪迪 Sata3 256G SSD</li><li>两条杂牌 M2 128G SSD</li><li>两块 2.5 寸机械硬盘 500G 1T</li><li>五块 3.5 寸机械硬盘 均 500G, 目前看来是不够的, 还会再买.</li></ol><p>购入 256g nvme ssd 一条, 牌子就不说了</p><h3 id="机箱">机箱</h3><ol><li>蜗牛星际 B 款 不是前面提到的已经在用的 nas, 是双十一新买的, 50+邮费 20</li><li>迎广 肖邦 只有两个硬盘位, 用不上.</li><li>一台工控机, 只有两个硬盘位, 更用不上.</li></ol><h2 id="需求">需求</h2><ol><li>用来跑数据库, 比如 mysql, mongodb, redis 等等, 需要跑在两块 raid1 硬盘上.</li><li>挂 bt, 不需要 raid.</li><li>备份电脑数据, 跟(1)一起放在 raid1 上.</li></ol><p>所以需要购买的只有几块硬盘和新电源. 星际蜗牛的 4 个硬盘位已经足够了. 两块硬盘组 raid1, 两块硬盘直接用.</p><p>如果以后需求大了, 需要升级更多硬盘的话, 可以换一个新的机箱, 用 pcie 接一个阵列卡, 最多能支持 12 块硬盘.</p><p>最后选择了蜗牛星际的廉价机箱, 到手之后是 B 款. 硬盘还没买. 先用了剩下的四块硬盘硬盘.</p><p>硬盘还没选好, 先把其他的硬件装起来了.</p><p><img src="../static/nas/bd69bf14ly1ga6r768jf7j23402c04qx.jpg" alt="机箱架子"><br><img src="../static/nas/bd69bf14ly1ga6r674zqxj22c0340kjt.jpg" alt="正面"></p><p><img src="../static/nas/bd69bf14ly1ga6r542c9aj22c0340e8a.jpg" alt="之前的itx机箱"></p><p>空间非常紧张, 说紧凑也行</p><p><img src="../static/nas/bd69bf14ly1ga6r4qqltgj22c0340b2g.jpg" alt="好几年没见"></p><p><img src="../static/nas/bd69bf14ly1ga6r47dg8gj22c03407wr.jpg" alt="CPU背板"></p><p>已经有点生锈了</p><p><img src="../static/nas/bd69bf14ly1ga6r3qvkv5j22c03407wq.jpg" alt="20191222_152216649_iOS.heic"></p><p>这个机箱要把所有的线接上之后再把主板扣上去.</p><p>原装散热器的高度是足够的, 为了方便安装我还是换了一个比较矮的<code>IS-30</code>, 高度 3cm, 是一开始担心原装散热器太高买的.</p><h2 id="系统">系统</h2><p>纠结了半天, 还是没直接用 debian 或者 ubuntu 这种发行版, 选择了 OpenMediaVault.</p><p>用了一天, 很满足我的需求(因为我经常会 ssh 上去), 但是单纯作为 nas 的话, web 界面功能想必万由易用性还是差很多.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现成已有的 nas：一台蜗牛星际 B 口单百兆，现在放了四块 500G 的硬盘租了一个 raid6。除去硬盘成本 268（机器）+200（电源）, 硬盘是旧硬盘. 用了三四个月之后已经有三四块硬盘报警了.&lt;/p&gt;
&lt;p&gt;总是觉得有些不爽，主要是又不想把现有 nas 里面的数据都拷出来换硬盘，又觉得现在的百兆和 1T 容量不太能让人满意，所以想搞一个千兆的高性能 nas。&lt;/p&gt;
&lt;p&gt;看了看市面上 nas 的价格，感觉硬件配置又不太对的起价格，于是决定自己搞一个。正好自己现在还闲置着一台核显的 itx 小机器&lt;/p&gt;</summary>
    
    
    
    
    <category term="nas" scheme="https://blog.trim21.me/tag/nas/"/>
    
  </entry>
  
  <entry>
    <title>用pyenv安装python</title>
    <link href="https://blog.trim21.me/2019/12/pyenv-build-python.html"/>
    <id>https://blog.trim21.me/2019/12/pyenv-build-python.html</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/pyenv/pyenv">pyenv</a>是用来安装多个版本的 python</p><span id="more"></span><p>官方提供了安装脚本</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">curl https://cdn.jsdelivr.net/gh/pyenv/pyenv-installer/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>(用 jsdeliver 是因为 raw.githubusercontent.com 现在访问不通了)</p><p>启用 cache:</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">mkdir -p .pyenv/cache</span><br></pre></td></tr></table></figure><p>使用 ccache, 可以缓存构件中的对象</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/yyuu/pyenv-ccache.git $(pyenv root)/plugins/pyenv-ccache</span><br><span class="line">sudo apt install ccache</span><br></pre></td></tr></table></figure><p>安装过程中会出现的错误</p><p>zipimport.ZipImportError: can't decompress data; zlib not available</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt install zlib1g-dev</span><br></pre></td></tr></table></figure><p>WARNING: The Python bz2 extension was not compiled. Missing the bzip2 lib?</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt install libbz2-dev</span><br></pre></td></tr></table></figure><p>WARNING: The Python readline extension was not compiled. Missing the GNU readline lib?</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libreadline-dev</span><br></pre></td></tr></table></figure><p>ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib?</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure><p>WARNING: The Python sqlite3 extension was not compiled. Missing the SQLite3 lib?</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt install libsqlite3-dev</span><br></pre></td></tr></table></figure><p>实际使用的时候可能会报错</p><p>ModuleNotFoundError: No module named '_ctypes'</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt install libffi-dev</span><br></pre></td></tr></table></figure><p>跟<code>pyinstaller</code>一起使用，需要添加一个编译选项:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PYTHON_CONFIGURE_OPTS=<span class="string">&quot;--enable-shared&quot;</span></span><br></pre></td></tr></table></figure><p><code>xxenv-latest</code> 用来直接选中最新的版本，比如使用 3.8 来选中最新的 3.8.9 版本。</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/momo-lab/xxenv-latest.git &quot;$(pyenv root)&quot;/plugins/xxenv-latest</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/pyenv/pyenv&quot;&gt;pyenv&lt;/a&gt;是用来安装多个版本的 python&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
    <category term="linux" scheme="https://blog.trim21.me/tag/linux/"/>
    
  </entry>
  
  <entry>
    <title>输入法切换到Rime</title>
    <link href="https://blog.trim21.me/2019/10/migrate-to-rime.html"/>
    <id>https://blog.trim21.me/2019/10/migrate-to-rime.html</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2021-08-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>QQ 拼音终于也开始弹广告了，所以一怒之下准备删了。</p><p>又不能没输入法用，就用上了小狼毫。记录一下这中间遇到的若干坑。</p><span id="more"></span><p><img src="../static/rime-preview.jpg" alt="最终设置的效果"></p><h2 id="安装">安装</h2><p>一路下一步，唯一的坑在于<code>自定义用户文件夹</code>这个功能。<strong>不要设置自定义用户文件夹</strong>。</p><p>如果是为了 rime 的多平台同步，rime 有另一个同步功能可以进行同步，而不需要同步整个用户文件夹。</p><p>rime 有一个包管理器，但是这个包管理器在 windows 上并不能正确的识别用户文件夹：无论用户怎么设置，包管理器都会认为用户文件夹在默认的 <code>%APPDATA%/rime</code>。包管理器也只会把下载到文件安装到这个路径里面，但小狼毫只从用户设置的文件夹中加载配置。这样一来，包管理器完全无法工作。</p><h2 id="同步">同步</h2><p>同步 rime 有一个自带的同步功能，也就是安装完后看到的<code>【小狼毫】用戶資料同步</code>开始菜单选项。</p><p>首先打开用户文件夹中的<code>installtion.yaml</code>（我就不介绍 yaml 语法了）<br>，添加一个<code>sync_dir</code>选项指向你想要同步的位置，比如我设置的是<code>$OneDrive/rime</code>，那么在点击同步之后，rime 会在<code>$sync_dir</code>文件夹下新建一个文件夹，名为这个文件里面的<code>id</code>一项（这一项你也是可以改的，比如我改成了<code>windows</code>），然后把你这台机器里面的所有配置和和词库同步过去。</p><p>如果 rime 在这个文件夹下面还找到了其他机器的同步结果，他还会合并其他机器的词库，所以只要定时的让小狼毫自动同步，就能解决多台机器的同步问题。</p><h2 id="设置">设置</h2><p>Rime 所有的设置（除了词库文件）都是 yaml，为了能合并不同的 YAML 中的，rime 用到了一些关键词比如<code>patch</code>。</p><p>小狼毫的配置文件在<code>$RIME_CONFIG_DIR/weasel.custom.yaml</code>中。</p><h3 id="设置外观">设置外观</h3><h4 id="设置候选词数量">设置候选词数量</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">&quot;menu/page_size&quot;:</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="设置主题">设置主题</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">&quot;style/color_scheme&quot;:</span> <span class="string">steam</span></span><br><span class="line">  <span class="attr">&quot;style/font_face&quot;:</span> <span class="string">&quot;Microsoft YaHei&quot;</span> <span class="comment"># 显示字体</span></span><br><span class="line">  <span class="attr">&quot;style/font_point&quot;:</span> <span class="number">14</span> <span class="comment"># 字体大小</span></span><br><span class="line">  <span class="attr">&quot;style/horizontal&quot;:</span> <span class="literal">true</span> <span class="comment"># 水平显示</span></span><br><span class="line">  <span class="attr">&quot;style/layout/margin_x&quot;:</span> <span class="number">7</span> <span class="comment"># 窗口边界距离</span></span><br><span class="line">  <span class="attr">&quot;style/layout/margin_y&quot;:</span> <span class="number">7</span> <span class="comment"># 窗口边界距离</span></span><br><span class="line">  <span class="attr">&quot;style/layout/spacing&quot;:</span> <span class="number">2</span> <span class="comment">#候选竖排时候与候选词的间距</span></span><br><span class="line">  <span class="attr">&quot;style/layout/candidate_spacing&quot;:</span> <span class="number">1</span> <span class="comment"># 候选间距</span></span><br><span class="line">  <span class="attr">&quot;style/layout/round_corner&quot;:</span> <span class="number">8</span> <span class="comment"># 圆的拐角</span></span><br><span class="line">  <span class="comment"># 还有一些额外的设置，这不是完整的列表，只是我用到的</span></span><br></pre></td></tr></table></figure><p><code>style/color_scheme</code> 设置了内置的配色方案，完整的列表可以在这里找到 <a href="https://github.com/rime-aca/color_schemes">https://github.com/rime-aca/color_schemes</a></p><p>如果觉得内置的都不好看，可以用<a href="https://bennyyip.github.io/Rime-See-Me/">配色方案生成器</a>自己设计一个。</p><h3 id="设置输入方案">设置输入方案</h3><p>输入方案的设置在 <code>$RIME_CONFIG_DIR/default.custom.yaml</code>。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">schema:</span> <span class="string">double_pinyin_flypy</span></span><br></pre></td></tr></table></figure><p><code>double_pinyin_flypy</code> 从<a href="https://github.com/rime/rime-double-pinyin">这里</a>安装，我是直接复制了原文件到我的配置文件夹中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;QQ 拼音终于也开始弹广告了，所以一怒之下准备删了。&lt;/p&gt;
&lt;p&gt;又不能没输入法用，就用上了小狼毫。记录一下这中间遇到的若干坑。&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://blog.trim21.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>给win10应用商店设置代理</title>
    <link href="https://blog.trim21.me/2019/06/set-proxy-for-win10-store.html"/>
    <id>https://blog.trim21.me/2019/06/set-proxy-for-win10-store.html</id>
    <published>2019-06-26T13:32:31.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>最近网络状况实在是不好,用 win10 应用商店下载应用怎么也不成功.修改系统代理也不管用.<br>参照<a href="https://sspai.com/post/41137">少数派的这篇文章</a>设置了代理,总算是解决了问题.</p><span id="more"></span><p>其中,最麻烦的是找到对应 uwp 应用的 sid,因为是要在表里一项一项的去找.</p><p>win10 商店对应的应用在注册表中的<code>DisplayName</code>是<code>Microsoft.WindowsStore</code>,<br>所以遍历<code>HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings</code>的所有子 key,找到对应<code>DisplayName</code>中包含<code>Microsoft.WindowsStore</code>的一项就可以了.</p><p>因为手动一项一项的去找效率实在是太低,就直接写了个 python 脚本来遍历.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> winreg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterkeys</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 获取该键的所有子键，因为没有方法可以获取子键的个数，所以只能用这种方法进行遍历</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># EnumValue方法用来枚举键值，EnumKey用来枚举子键</span></span><br><span class="line">            <span class="keyword">yield</span> winreg.EnumKey(key, i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> WindowsError:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itervalues</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 获取该键的所有键值，因为没有方法可以获取键值的个数，所以只能用这种方法进行遍历</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># EnumValue方法用来枚举键值，EnumKey用来枚举子键</span></span><br><span class="line">            name, value, _ = winreg.EnumValue(key, i)</span><br><span class="line">            d[name] = value</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> WindowsError:</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    base_key = (</span><br><span class="line">        <span class="string">r&quot;Software\Classes\Local Settings\Software&quot;</span></span><br><span class="line">        <span class="string">r&quot;\Microsoft\Windows\CurrentVersion\AppContainer\Mappings\\&quot;</span></span><br><span class="line">    )</span><br><span class="line">    mappings = winreg.OpenKey(winreg.HKEY_CURRENT_USER, base_key)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> iterkeys(mappings):</span><br><span class="line">        k = winreg.OpenKey(winreg.HKEY_CURRENT_USER, base_key + key)</span><br><span class="line">        info = itervalues(k)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;WindowsStore&#x27;</span> <span class="keyword">in</span> info[<span class="string">&#x27;DisplayName&#x27;</span>]:</span><br><span class="line">            <span class="built_in">print</span>(info[<span class="string">&#x27;DisplayName&#x27;</span>])</span><br><span class="line">            <span class="built_in">print</span>(key)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>直接保存成 py 文件,然后运行,控制台的第二行会输出类似<code>S-1-15-2-****</code>的一个 SID,就是在<code>CheckNetIsolation.exe loopbackexempt -a -p=$&#123;SID&#125;</code>中要用到的 SID.</p><p>这之后,设置系统代理,重启 win10 商店,就能通过代理下载应用了.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近网络状况实在是不好,用 win10 应用商店下载应用怎么也不成功.修改系统代理也不管用.&lt;br&gt;
参照&lt;a href=&quot;https://sspai.com/post/41137&quot;&gt;少数派的这篇文章&lt;/a&gt;设置了代理,总算是解决了问题.&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
    <category term="windows" scheme="https://blog.trim21.me/tag/windows/"/>
    
  </entry>
  
  <entry>
    <title>用PyInstaller打包python应用</title>
    <link href="https://blog.trim21.me/2019/06/build-python-package-with-pyinstaller.html"/>
    <id>https://blog.trim21.me/2019/06/build-python-package-with-pyinstaller.html</id>
    <published>2019-06-02T15:47:34.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>那天突然好奇，<code>docker-compose</code>是用什么语言写的。然后一看，发现居然是用 python2 写的。</p><p>但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用<a href="https://github.com/pyinstaller/pyinstaller"><code>PyInstaller</code></a>来进行打包的，把一个 python 应用打包成单个的二进制文件。</p><p>一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。</p><p>但用<code>PyInstaller</code>，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。</p><span id="more"></span><p>首先，PyInstaller 的工作原理是从一个 py 文件出发在静态分析出所有用到的依赖，然后把所有的依赖打包起来，在用户使用二进制的时候释放到一个临时文件夹中，用 Python 解释器来运行。</p><p>PyInstaller 入门的文章已经有很多了，就不再重复写一遍了，主要遇到的坑有这么几个。</p><h2 id="用到的非-py-文件要手动指定路径一起打包">用到的非 py 文件要手动指定路径一起打包</h2><p>我的程序中用到了一些模板文件，是在程序运行起来之后才根据需要加载决定是否渲染的。这些文件因为不是 python 文件，所以 PyInstaller 在分析的时候也不会知道是程序的一部分，就不会打包在二进制中。</p><p>在程序运行的时候，如果用到了对应的文件，因为没有被打包进来的缘故，程序就会报错。</p><p>如果用命令行来指定要一起打包的文件效率过低，所以可以编写一个 spec 文件来告诉 PyInstaller 要如何打包。</p><p>（这是我之前尝试打包我的程序是用到的 spec 文件，但是因为不支持<code>entry_points</code>的原因，所以我最后放弃了使用这个办法，但是打包出来的程序在不用到<code>entry_points</code>的情况下是跟直接使用 pip 安装行为一致的。）</p><p><code>bgmi.spec</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- mode: python -*-</span></span><br><span class="line"><span class="keyword">from</span> PyInstaller.building.api <span class="keyword">import</span> EXE, PYZ</span><br><span class="line"><span class="keyword">from</span> PyInstaller.building.build_main <span class="keyword">import</span> Analysis</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">bindata_dir = [</span><br><span class="line">    <span class="string">&#x27;bgmi/front/templates&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;bgmi/lib/models/migrations&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bindata</span>():</span><br><span class="line">    <span class="keyword">for</span> dir_path <span class="keyword">in</span> bindata_dir:</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(dir_path):</span><br><span class="line">            <span class="keyword">yield</span> (os.path.join(dir_path, file), dir_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">block_cipher = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">package_imports = [[<span class="string">&#x27;peewee_migrate&#x27;</span>, [<span class="string">&#x27;template.txt&#x27;</span>]]]</span><br><span class="line">datas = <span class="built_in">list</span>(get_bindata())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> package, files <span class="keyword">in</span> package_imports:</span><br><span class="line">    proot = os.path.dirname(importlib.import_module(package).__file__)</span><br><span class="line">    datas.extend((os.path.join(proot, f), package) <span class="keyword">for</span> f <span class="keyword">in</span> files)</span><br><span class="line"></span><br><span class="line">a = Analysis([<span class="string">&#x27;bgmi/__main__.py&#x27;</span>],</span><br><span class="line">             pathex=[<span class="string">&#x27;.&#x27;</span>],</span><br><span class="line">             hiddenimports=[],</span><br><span class="line">             hookspath=<span class="literal">None</span>,</span><br><span class="line">             datas=datas,</span><br><span class="line">             runtime_hooks=<span class="literal">None</span>,</span><br><span class="line">             cipher=block_cipher)</span><br><span class="line"></span><br><span class="line">pyz = PYZ(a.pure, cipher=block_cipher)</span><br><span class="line"></span><br><span class="line">exe = EXE(</span><br><span class="line">    pyz,</span><br><span class="line">    a.scripts,</span><br><span class="line">    a.binaries,</span><br><span class="line">    a.zipfiles,</span><br><span class="line">    a.datas,</span><br><span class="line">    name=<span class="string">&#x27;bgmi&#x27;</span>,</span><br><span class="line">    debug=<span class="literal">False</span>,</span><br><span class="line">    strip=<span class="literal">None</span>,</span><br><span class="line">    upx=<span class="literal">True</span>,</span><br><span class="line">    console=<span class="literal">True</span>,</span><br><span class="line">    bootloader_ignore_signals=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，<code>a = Analysis(['bgmi/__main__.py'],</code>为程序的入口就是原本如果使用命令行的话，在 PyInstaller 后面跟的那个 py 文件路径。</p><p>而<code>get_bin_data</code>则是找到所有要打包进去的非 py 文件，告诉 PyInstaller 这些文件需要打包。<code>datas</code>的格式应该是一个<code>List[List]</code>。而内部的列表第一个元素是文件的路径，第二个元素是文件要打包到的文件夹。</p><p>比如说，如果要一起打包<code>a/b/c.txt</code>文件，<code>datas</code>中就应该添加一项<code>[('a/b/c.txt', 'a/b'), ]</code>，含义是告诉 PyInstaller 要把<code>。/b/c.txt</code>文件打包到<code>a/b</code>文件夹中，如果要打包整个文件夹，我不太确定能不能直接填写文件夹的路径，我是选择了用 python 列出文件夹内的所有文件，然后一股脑的添加到 datas 里面。</p><p>而如果你用到的某个依赖（没错，在我这个例子里面就是<code>peewee-migrate</code>，他有一个<code>template.txt</code>文件，是在运行的时候动态读取的，同样需要添加到 datas 中。</p><p>就是这段代码实现的功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package_imports = [</span><br><span class="line">    [<span class="string">&#x27;peewee_migrate&#x27;</span>, [<span class="string">&#x27;template.txt&#x27;</span>]],</span><br><span class="line">]</span><br><span class="line">datas = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> package, files <span class="keyword">in</span> package_imports:</span><br><span class="line">    proot = os.path.dirname(importlib.import_module(package).__file__)</span><br><span class="line">    datas.extend((os.path.join(proot, f), package) <span class="keyword">for</span> f <span class="keyword">in</span> files)</span><br></pre></td></tr></table></figure><p>在<code>package_imports</code>中定义每个包需要额外引入的文件，在下面循环中找到所有需要打包的文件的路径，然后添加到 data 中去。</p><h2 id="支持-entry-point">支持 entry_point</h2><p>这个支持 entry point 的意思不是说，我用来有一个用<code>console_scripts</code>做为入口的 python 程序如何用 pyinstaller 打包。</p><p>而是说，如果你在<code>entry_points</code>里添加了其他的东西，比如说我的 python 程序中添加了这样的几个<code>entry_points</code>。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[options.entry_points]</span></span><br><span class="line"><span class="attr">bgmi.downloader.delegate</span> =</span><br><span class="line">  <span class="attr">aria2-rpc</span> = bgmi.downloader.aria2_rpc:Aria2DownloadRPC</span><br><span class="line">  <span class="attr">deluge-rpc</span> = bgmi.downloader.deluge:DelugeRPC</span><br><span class="line">  <span class="attr">transmission-rpc</span> = bgmi.downloader.transmissionRpc:TransmissionRPC</span><br></pre></td></tr></table></figure><p>如果程序是通过<code>pip install -e .</code>安装到 python 环境中的，在运行程序的时候可以正常被<code>load_entry_point</code>加载。</p><p>但如果是在 pyinstaller 打包出来的二进制中，默认程序是无法加载到任何<code>entry_points</code>的，因为<code>PyInstaller</code>默认只会打包所有的 py 文件，而一个包的<code>entry_points</code>的信息保存在<code>package</code>同级的目录<code>package.egg-ino/entry_points.txt</code>文件中，需要用之前提到的办法，把这个文件夹也打包进去，而且要跟<code>package</code>同级。这样在运行释放临时文件的时候，才能正常加载<code>package</code>对应的<code>entry_points</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;那天突然好奇，&lt;code&gt;docker-compose&lt;/code&gt;是用什么语言写的。然后一看，发现居然是用 python2 写的。&lt;/p&gt;
&lt;p&gt;但想到我安装的时候从来没在乎过机器上有没有安装 python，或者我的 python 版本是多少，而是按照官网的文档，直接下载一个二进制文件来安装的。突然眼前一亮。看了一下对应的构建代码，发现他是用&lt;a href=&quot;https://github.com/pyinstaller/pyinstaller&quot;&gt;&lt;code&gt;PyInstaller&lt;/code&gt;&lt;/a&gt;来进行打包的，把一个 python 应用打包成单个的二进制文件。&lt;/p&gt;
&lt;p&gt;一般来说，正常的 python 包的分发会基于 pip 的，发布到 pypi 和用户下载的都是代码文件（和其他语言编译的二进制文件），如果依赖于其他的 package 会在安装的时候再进行下载。&lt;/p&gt;
&lt;p&gt;但用&lt;code&gt;PyInstaller&lt;/code&gt;，打包出来的可执行文件中包含了所有用到的依赖和 python 解释器，并不需要本机安装了 python 或者 pip，像 docker-compose 这样的工具，打包之后成一个单文件，对于用户在安装和使用的时候都会方便许多，而对于我们开发者来说，就不用考虑兼容旧的 python 版本，可以直接使用 python3.6 的新语法如 type annotation 等，使用某些只有 python3.6 以上版本才能用的依赖库，自然也比原来爽了许多。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
  </entry>
  
  <entry>
    <title>参与python文档的中文翻译</title>
    <link href="https://blog.trim21.me/2019/03/join-python-zh-cn-translaters.html"/>
    <id>https://blog.trim21.me/2019/03/join-python-zh-cn-translaters.html</id>
    <published>2019-03-30T17:28:36.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到这个帖子<a href="https://www.v2ex.com/t/550164">别开心太早， Python 官方文档的翻译差远了 - V2EX</a> 发现参与 python 文档翻译的门槛还挺低的，就尝试了一下翻译了两段文档.</p><h2 id="参与翻译的方法">参与翻译的方法</h2><span id="more"></span><p>按照 <a href="https://www.python.org/dev/peps/pep-0545/">pep-545</a>的说法, 有三步需要做:</p><ol><li>注册一个 <a href="https://bugs.python.org">https://bugs.python.org</a> 的账号, 这个用户名在签 license 的时候会用到.</li><li>签 license <a href="https://www.python.org/psf/contrib/">介绍</a> 具体签署是在<a href="https://www.python.org/psf/contrib/contrib-form/">这个页面上</a> 用的 adobe sign, 填完那个 iframe 里面的几个框就能提交了.</li><li>注册 transifex, 选择自己的语言, 并且<a href="https://www.transifex.com/python-doc/python-newest/">申请加入</a></li></ol><p>然后等待被允许加入团队, 然后就可以开始翻译了.</p><p>翻译是以每段为单位进行的</p><p><img src="../static/bd69bf14ly1g1l2x2j9x2j20yh0po7fd.jpg" alt=""></p><p><a href="https://github.com/python/python-docs-zh-cn">python/python-docs-zh-cn: zh_CN translation of the Python documentation</a></p><p>中文的 po 文件在这个仓库里, 每个小时会有一个 bot 会自动把 transifex 上面的翻译同步到仓库里面去, 但是自己的名字并不会出现在这个仓库的 contributors 里面, 233</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天看到这个帖子&lt;a href=&quot;https://www.v2ex.com/t/550164&quot;&gt;别开心太早， Python 官方文档的翻译差远了 - V2EX&lt;/a&gt; 发现参与 python 文档翻译的门槛还挺低的，就尝试了一下翻译了两段文档.&lt;/p&gt;
&lt;h2 id=&quot;参与翻译的方法&quot;&gt;参与翻译的方法&lt;/h2&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
  </entry>
  
  <entry>
    <title>golang笔记</title>
    <link href="https://blog.trim21.me/2018/11/learning-golang.html"/>
    <id>https://blog.trim21.me/2018/11/learning-golang.html</id>
    <published>2018-11-01T09:25:15.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些约定">一些约定</h2><ol><li>使用驼峰命名法</li><li>首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)</li></ol><span id="more"></span><h2 id="数据类型">数据类型</h2><h3 id="bool">bool</h3><p>布尔, <code>true</code>或者<code>false</code></p><h3 id="string">string</h3><p>字符串, 使用双引号 比如<code>&quot;hello world&quot;</code></p><h3 id="rune">rune</h3><p>类似于字符, 在使用<code>for _, char := range string</code>迭代 string 的时候, char 的类型就是 rune</p><h3 id="int">int</h3><p>未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用<code>int()</code>转化为 int</p><h3 id="byte">byte</h3><p><code>[]byte</code>可以跟 string 互相转化, <code>len(string)</code>的长度实际上就是 string 转化为<code>[]byte</code>之后的长度. 每个 unicode 的长度为 3. 比如说<code>len(&quot;hello world&quot;)==11</code>, 但是<code>len(&quot;你好 世界&quot;)</code>的长度为 3+3+1=7. 每个汉字因为是 unicode 所以为 3.</p><h3 id="指针">指针</h3><p>可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)</p><h3 id="数组">数组</h3><p>用于存放类型相同的一组数据.</p><h4 id="slice">slice</h4><p>可变长度</p><h4 id="array">array</h4><p>长度不可变</p><h3 id="map">map</h3><p>类似于 python 中的 dict, 但是需要指定 key 和 value 的类型</p><p>比如 python 中的<code>Map[str, str]</code>在 golang 中为<code>map[string]string</code>, 这个 map 只能以 string 为 key, 以 string 为 value.</p><p>如果要一个可以存储任意数据类型的 map 可以<code>map[string]interface&#123;&#125;</code></p><h3 id="函数">函数</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(arg1 argType1, arg2 argType2)</span></span> (returnType1, returnType2)&#123;</span><br><span class="line">    main body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang 中, 变量的类型是放在变量名之后的.</p><h3 id="struct">struct</h3><p>结构体, 类似于 python 中的 class.</p><h4 id="定义">定义</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Episode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title   <span class="type">string</span></span><br><span class="line">    Torrent <span class="type">string</span></span><br><span class="line">    Episode <span class="type">int</span></span><br><span class="line">    Time    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化">初始化</h4><p>使用大括号</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e = Episode&#123;</span><br><span class="line">    Title:   <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    Episode: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体的方法">结构体的方法</h4><p>如果要在其上绑定函数, 使用</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(episode *Episode)</span></span> getTitle() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> episode.Title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条用跟其他语言的调用方法类似.</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">e.getTitle()</span><br></pre></td></tr></table></figure><h3 id="接口-interface">接口 interface</h3><p>还没有实际用到, 所以只有一些粗浅的理解.</p><p>interface 接口是为了面向对象而出现的, 一个函数可以参数可以为一系列不特定的类型, 但无所谓具体的类型, 只要这个类型实现了特定的方法即可.</p><p>比如一个<code>writeTo</code>函数接受一个<code>io.Writer</code>的参数</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeTo</span><span class="params">(w io.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.Writer</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要是实现了<code>Write</code>方法的, 输入值和返回值匹配<code>([]byte) (int, error)</code>类型都可以做为这个函数的参数. 比如说默认的标准库<code>os</code>提供的<code>os.Stdout</code>就是一个实现了<code>io.Writer</code>接口的类型. 比如说, 这里就可以以<code>writeTo(os.Stdout)</code>的形式调用.</p><h3 id="channel">channel</h3><p>信道</p><p>go 并发中, 不同<code>goroutine</code>的通信工具.</p><p>无缓冲区或者缓冲区已满的情况下进行写入是阻塞的.</p><p>如果信道为空, 而试图读取也会阻塞.</p><p>只有读取没有写入或者只有写入没有读取会导致死锁.</p><h2 id="并发编程">并发编程</h2><p>golang 提供了<code>go</code>关键词来开启一个<code>goroutine</code>.</p><p>因为 goroutine 函数的返回值是会被丢弃的, 使用回调函数的话又会陷入回调地域中, 所以需要一种额外的方式来接受异步函数的返回结果.</p><p>这里就要贴出那句 go 并发文章常常能看到的话了</p><blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存</p></blockquote><p>而<code>channel</code>, 就是 go 提供的通信的工具. 可以在一个线程中发送数据, 在另一个线程中接收数据. 如果我们要写一个异步爬虫, 就可以开四个线程来爬取数据, 在爬到数据后通过 channel 发送到主线程, 然后在主线程中使用 channel 接受, 交给 pipeline 来处理.</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">costumer</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> each := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;costume %d\n&quot;</span>, each)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> costumer(c)</span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">5</span>; index++ &#123;</span><br><span class="line">        c &lt;- index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>go costumer(channel)</code>启动了一个新的消费者线程, 而主线程自己也是一个<code>goroutine</code>, 虽然跟<code>costumer</code>不在同一个线程中, 但是仍然可以通过 channel 通信, 在这里, 主线程就是生产者, 消费者模型中的生产者.</p><h3 id="并发控制">并发控制</h3><p>有时候并不需要很大的并发量, 比如我们只想起 4 个或者 8 个生产者, 可以使用<code>sync.WaitGroup</code>来进行并发控制.</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> controller = newController(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">20</span>; index++ &#123;</span><br><span class="line">        urls = <span class="built_in">append</span>(urls, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, index))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> controller.dispatchGocoutine(urls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each := <span class="keyword">range</span> controller.output &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;collect output &quot;</span> + each)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> asyncControl <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrg       sync.WaitGroup</span><br><span class="line">    output     <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    goroutineCnt <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newController</span><span class="params">(size <span class="type">int</span>)</span></span> *asyncControl &#123;</span><br><span class="line">    d := <span class="built_in">new</span>(asyncControl)</span><br><span class="line">    d.wrg = sync.WaitGroup&#123;&#125;</span><br><span class="line">    d.output = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    d.goroutineCnt = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, size)</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(controller *asyncControl)</span></span> dispatchGocoutine(urls []<span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        controller.goroutineCnt &lt;- <span class="number">0</span> <span class="comment">// 限制线程数</span></span><br><span class="line">        controller.wrg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> controller.asyncTask(url)</span><br><span class="line">    &#125;</span><br><span class="line">    controller.wrg.Wait() <span class="comment">// 等待至所有分发出去的线程结束</span></span><br><span class="line">    <span class="built_in">close</span>(controller.output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(controller *asyncControl)</span></span> asyncTask(url <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-controller.goroutineCnt</span><br><span class="line">        controller.wrg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// some task here</span></span><br><span class="line">    controller.output &lt;- <span class="string">&quot;processed &quot;</span> + url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为提到在缓冲区已满的情况下写入是阻塞的, 所以可以利用这一点来进行并发控制. <code>goroutineCnt</code>就是用来控制最大线程数的任务. 当我们试图开启一个新的线程的时候, 先向<code>goroutineCnt</code>中进行一次写入, 再开启一个新的任务. 而在工作进程中, 在整个函数执行完成后则从<code>goroutineCnt</code>中进行一次读取. 缓冲区就会空出一位来, 而进行工作分发的线程的阻塞此时就结束了, 在成功写入信道之后则会开启一个新的线程. 保持工作线程数量永远不会超过<code>goroutineCnt</code>的缓冲区长度.</p><p>这个<code>sync.WaitGroup</code>是另一个并发的工具, 因为不能确定其他 goroutine 什么时候才能结束, 所以使用<code>wrk.Wait()</code>来在分发结束后阻塞分发的线程, 在所有分发出去的线程结束后关闭信道.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一些约定&quot;&gt;一些约定&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用驼峰命名法&lt;/li&gt;
&lt;li&gt;首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="golang" scheme="https://blog.trim21.me/tag/golang/"/>
    
  </entry>
  
  <entry>
    <title>在UserScript中使用Vue</title>
    <link href="https://blog.trim21.me/2018/10/use-vue-in-userscript.html"/>
    <id>https://blog.trim21.me/2018/10/use-vue-in-userscript.html</id>
    <published>2018-10-11T07:26:00.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一个用户脚本, <a href="https://github.com/Trim21/bgm-tv-auto-tracker">在站外一键点 bgm 格子</a> 为了添加一个 UI, 但又不想用 jQuery 手动绑一堆事件, 就直接上了 Vue. 所以需要用 Webpack 打包对应的 vue 文件到 userscript 里.</p><span id="more"></span><p><img src="../static/bd69bf14ly1fw4c4bspy5j20b10cagmq.jpg" alt="效果图"></p><p>按钮和弹出框都是 Vue 做的.</p><p>因为之前一直用的是<code>vue-cli</code>提供的 webpack 模板, 所以不太熟悉 webpack, 踩了不少坑.</p><p>参考<a href="https://vue-loader.vuejs.org/guide/">vue-loader</a></p><p>首先在 webpack 的设置中添加一个<code>loader</code>, 再添加一个插件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueLoaderPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;vue-loader/lib/plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// ... other rules</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;vue-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">loaders</span>: &#123;</span><br><span class="line">            <span class="attr">scss</span>: <span class="string">&quot;vue-style-loader!css-loader!postcss-loader!sass-loader&quot;</span>,</span><br><span class="line">            <span class="comment">// &lt;style lang=&quot;scss&quot;&gt;</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// make sure to include the plugin!</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在代码里, 参照 Vue 官方的模板, 只要初始化一个实例就能正常显示内容了.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;. /App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#container&quot;</span>).<span class="title function_">append</span>(<span class="string">`&lt;div id=&#x27;bgm_tv_app&#x27;&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$http</span> = axios;</span><br><span class="line"><span class="comment">// eslint-disable-next-line no-new</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#bgm_tv_app&quot;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中, <code>el</code>就是要绑定元素, 因为网页上一般没有, 所以往往还是要用 JS 手动插一个进去, 然后再初始化 Vue.</p><p>然后为了能编译出来的文件不会显示一些无用的更改, 最好加上<a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/">HashedModuleIdsPlugin</a>等.</p><p>同时为了减小最后编译出来的脚本文件的体积, 最好使用 webpack 的 external 设置, 比如 Vue, jQuery 之类的.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">externals</span>: &#123;</span><br><span class="line">  <span class="attr">jquery</span>: <span class="string">&#x27;$&#x27;</span>,</span><br><span class="line">  <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">  <span class="attr">axios</span>: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;axios-userscript-adapter&#x27;</span>: <span class="string">&#x27;axiosGmxhrAdapter&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以避免 webpack 把 Vue, axios 之类库的原文件打包进来, 造成脚本体积非常大.(但是要记得在 meta 里加上对应的 js 文件)</p><p>\EOF</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写了一个用户脚本, &lt;a href=&quot;https://github.com/Trim21/bgm-tv-auto-tracker&quot;&gt;在站外一键点 bgm 格子&lt;/a&gt; 为了添加一个 UI, 但又不想用 jQuery 手动绑一堆事件, 就直接上了 Vue. 所以需要用 Webpack 打包对应的 vue 文件到 userscript 里.&lt;/p&gt;</summary>
    
    
    
    
    <category term="javascript" scheme="https://blog.trim21.me/tag/javascript/"/>
    
    <category term="vue" scheme="https://blog.trim21.me/tag/vue/"/>
    
    <category term="userscript" scheme="https://blog.trim21.me/tag/userscript/"/>
    
  </entry>
  
  <entry>
    <title>生成bgm.tv关联条目网络</title>
    <link href="https://blog.trim21.me/2018/10/bgm.tv-ip-viewer.html"/>
    <id>https://blog.trim21.me/2018/10/bgm.tv-ip-viewer.html</id>
    <published>2018-10-11T02:50:36.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>本项目已弃坑。</p><p>先放成品 <a href="http://bgm-ip-viewer.trim21.cn">bgm-ip-viewer</a></p><p>在 bgm 上看到有人说现在的关联图只有一层, 看起来不太方便, 就爬了全站数据做了这么个东西.</p><span id="more"></span><h1>爬取数据并生成关联条目网络</h1><h2 id="爬取数据">爬取数据</h2><p>爬数据用的是<code>scrapy</code>, 因为本站有请求速度的限制, 所以数据源是镜像站.</p><p><code>scrapy</code>的流程是这样的, 首先继承<code>scrapy.Item</code>来定义你自己爬到的数据的模型.</p><p>比如我定义了条目 item</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubjectItem</span>(scrapy.Item):</span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="built_in">id</span> = Field()</span><br><span class="line">    _<span class="built_in">id</span> = Field()</span><br><span class="line">    name = Field()</span><br><span class="line">    image = Field()</span><br><span class="line">    subject_type = Field()</span><br><span class="line">    name_cn = Field()</span><br><span class="line">    tags = Field()</span><br><span class="line">    info = Field()</span><br><span class="line"></span><br><span class="line">    score = Field()</span><br><span class="line"></span><br><span class="line">    score_details = Field()</span><br><span class="line"></span><br><span class="line">    wishes = Field()</span><br><span class="line">    done = Field()</span><br><span class="line">    doings = Field()</span><br><span class="line">    on_hold = Field()</span><br><span class="line">    dropped = Field()</span><br></pre></td></tr></table></figure><p>每个<code>Field()</code>中保存的的数据类型可以是 <code>str</code>, <code>int</code>, <code>bool</code>等基础的数据类型, 也可以是<code>list</code>, <code>dict</code>这种组合类型.</p><p>然后写一个解析函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> bgm.items <span class="keyword">import</span> SubjectItem, RelationItem</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">url_from_id</span>(<span class="params">_<span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://mirror.bgm.rin.cat/subject/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(_<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BgmTvSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;bgm_tv&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;mirror.bgm.rin.cat&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://mirror.bgm.rin.cat/subject/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">                  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">270000</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;出错了&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            subject_item = SubjectItem()</span><br><span class="line"></span><br><span class="line">            subject_item[<span class="string">&#x27;subject_type&#x27;</span>] = get_subject_type(response)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> subject_item[<span class="string">&#x27;subject_type&#x27;</span>] == <span class="string">&#x27;Music&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            subject_item[<span class="string">&#x27;_id&#x27;</span>] = <span class="built_in">int</span>(response.url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">            subject_item[<span class="string">&#x27;id&#x27;</span>] = subject_item[<span class="string">&#x27;_id&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            subject_item[<span class="string">&#x27;info&#x27;</span>] = get_info(response)</span><br><span class="line">            subject_item[<span class="string">&#x27;tags&#x27;</span>] = get_teg_from_response(response)</span><br><span class="line">            subject_item[<span class="string">&#x27;image&#x27;</span>] = get_image(response)</span><br><span class="line">            subject_item[<span class="string">&#x27;score&#x27;</span>] = get_score(response)</span><br><span class="line">            subject_item[<span class="string">&#x27;score_details&#x27;</span>] = get_score_details(response)</span><br><span class="line"></span><br><span class="line">            title = response.xpath(<span class="string">&#x27;//*[@id=&quot;headerSubject&quot;]/h1/a&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            subject_item[<span class="string">&#x27;name_cn&#x27;</span>] = title.attrib[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">            subject_item[<span class="string">&#x27;name&#x27;</span>] = title.xpath(<span class="string">&#x27;text()&#x27;</span>).extract_first()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> edge <span class="keyword">in</span> get_relation(response, source=subject_item[<span class="string">&#x27;_id&#x27;</span>]):</span><br><span class="line">                relation_item = RelationItem(**edge, )</span><br><span class="line">                <span class="keyword">yield</span> relation_item</span><br><span class="line">                <span class="keyword">yield</span> Request(url_from_id(relation_item[<span class="string">&#x27;target&#x27;</span>]))</span><br><span class="line">            <span class="keyword">yield</span> subject_item</span><br></pre></td></tr></table></figure><p>框架有一个默认的<code>start_requests</code>函数, 会请求<code>starts_urls</code>里面的链接. 在获取到内容之后会进行一系列处理(比如解析 http, xpath 之类的), 然后交给<code>parse</code>函数来处理.</p><p><code>parse</code>函数实际上是一个生成器函数, 通过不断<code>yield</code>内容来告诉<code>scrapy</code>你要做什么.</p><p>如果我们需要爬一个新网页, 就<code>yield</code>一个<code>scrapy.Request</code>, <code>scrapy</code>在爬完对应的页面只有会交给对应的回调函数(默认为<code>parse</code>)</p><p>如果你爬到了一个<code>Item</code>, 就直接把对应的实例给 yield 出去. 然后<code>scrapy</code>会交给<code>pipeline</code>来处理.</p><p>在这个例子里, 我需要用到的有两种 item, 一种是<code>SubjectItem</code>, 包含条目的某些信息(比如标题, 封面, 对应的<code>subject_id</code>, 另一个是每个条目跟其他条目的关系<code>RelationItem</code>. 这个关系包括源条目, 目标条目, 和条目关系.)</p><p>然后要把对应的 item 存到数据库里, 就需要我们定义一个<code>pipeline</code>了.</p><p>最想吐槽的就是这里...</p><p>原来我已经用<code>aiohttp</code>写了一些东西, 自认为还比较熟悉异步了, 结果没想到 python 的异步库真是各自为战. <code>scrapy</code>是基于<code>twisted</code>的, 所以基于<code>asyncio</code>的异步库是不能在这里用的. 我数据库用的是<code>MongoDB</code>, 原本<code>mongodb</code>官方有一个数据库<code>motor</code>, 支持<code>tornado</code>和<code>asyncio</code>的 ioloop, 但是不支持<code>twisted</code>...</p><p>所以就算你了解 python 异步标准库的写法, 用另一个异步框架的时候还是可能一脸懵逼...</p><p>额外去找了一个<code>twisted</code>支持的 mongo 库<code>txmongo</code>, 用来存数据.</p><h2 id="数据处理">数据处理</h2><p>爬回来的数据不处理别说别人了, 我自己都看不懂.</p><p>回到我们一开始的目的, 把有关系的条目放在一起, 显示他们之间的关系.</p><p>最后显示出来的是一个力导向图啊, 那直接用 d3.js 好了, 找一个 d3.js 的 demo 来看看他需要的数据结构是什么样的.</p><p>参考了这篇文章</p><p><a href="https://blog.csdn.net/lzhlzz/article/details/40450379">【 D3.js 进阶系列 — 2.0 】 力学图 + 人物关系图</a></p><p>最后需要的是一个这样的数据结构</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;云天河&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tianhe.png&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;韩菱纱&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lingsha.png&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;柳梦璃&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mengli.png&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;慕容紫英&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ziying.png&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;edges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;挚友&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;挚友&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;挚友&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这正好就是我爬下来的数据的结构啊.</p><p>那就只剩下一个问题了, 怎么把同一张网节点和关系组合在一起.</p><p>本来想要直接一个 for 循环遍历, 发现这样有一个问题, 一个大的网络可能会断成好几个小的网络. 正好受到了<code>scrapy</code>爬取网站的办法, 在写一个 work 函数, 不停地把下一个需要处理的节点给<code>yield</code>出来, 然后从<code>yield</code>出来的节点不断的开始处理.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">start_job=<span class="literal">None</span></span>):</span><br><span class="line">    yield_job = []</span><br><span class="line">    done_id = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">if</span> start_job <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        start_job = [</span><br><span class="line">            x[<span class="string">&#x27;_id&#x27;</span>] <span class="keyword">for</span> x <span class="keyword">in</span> n_subject.find(&#123;&#125;, &#123;<span class="string">&#x27;_id&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">        ]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="built_in">len</span>(yield_job) + <span class="built_in">len</span>(start_job), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> yield_job:</span><br><span class="line">            j = yield_job.pop()</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> done_id:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> deal_with_node(&#123;<span class="string">&#x27;_id&#x27;</span>: j&#125;):</span><br><span class="line">                yield_job.append(node)</span><br><span class="line">            done_id.add(j)</span><br><span class="line">        <span class="keyword">elif</span> start_job:</span><br><span class="line">            j = start_job.pop()</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> done_id:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> deal_with_node(&#123;<span class="string">&#x27;_id&#x27;</span>: j&#125;):</span><br><span class="line">                yield_job.append(node)</span><br><span class="line">            done_id.add(j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>其中, 用来处理节点的函数<code>deal_with_noed(node)</code>首先获取节点跟其他节点的关系, 如果某个关系(比如角色歌, op, ed 之类的)不符合需要添加的条件就跳过, 如果符合条件, 先看看有没有一个现成的网络, 有就把对应节点加入到网络里, 没有就新建一个网络, 把对应节点加进去. 然后把对应节点<code>yield</code>出去.</p><p>可以看到, 我在外面<code>for node in deal_with_node(&#123;'_id': j&#125;):yield_job.append(node)</code>, 所以所有<code>yield</code>出来的节点都会成为下一个处理的节点. 这样一来会保证处理完一个网络只有的所有节点才会进行下一步, 处理下一个网络的节点.</p><p>这样一来, 就可以保证一个整体网络不会裂成两个网络.</p><h2 id="更新">更新</h2><p>迫于用来跑这个程序的服务器只有 1C1G, 跑了一堆服务器的情况下再跑一个 Mongo 太勉强了, 再加上腾讯的学生优惠还有 36 每年的 mysql(1G 内存, 50G 硬盘), 就买了一年的 mysql 实例用来存数据, 减轻服务器的内存压力.</p><p>然后就牵扯 twisted 异步操作数据库(其实同步也不是不行, 但是如果同步存储的话数据库就会成为爬虫的瓶颈, 所以还是异步比较合适.)</p><p>twisted 提供了一个<code>adbapi</code>, 一看就知道是异步数据库 api 的意思. 操作 mysql 的话, 需要<code>mysqlclient</code>或者<code>pymysql</code>+<code>pymysql.install_as_MySQLdb()</code>跟把数据保存到 mongo 一样, 添加一个<code>mysqlpipeline</code>的 pipeline.</p><p>为了避免手写 sql, 用了<code>peewee</code>做为 orm. peewee 的每个 query 都有一个<code>sql()</code>方法, 可以不让 peewee 执行具体的操作, 而是获取对应的 sql 语句, 然后交给 twisted 的<code>adbpi</code>来执行, 避免阻塞.</p><p><code>Relation</code>和 <code>Subject</code>是通过 peewee 定义的数据库 model.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bgm.items <span class="keyword">import</span> SubjectItem, RelationItem</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"><span class="keyword">from</span> bgm.models <span class="keyword">import</span> Subject, Relation</span><br><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"><span class="keyword">import</span> bgm.settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># from playhouse.shortcuts import keyli</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MysqlPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.dbpool = adbapi.ConnectionPool(</span><br><span class="line">            <span class="string">&quot;MySQLdb&quot;</span>,</span><br><span class="line">            host=bgm.settings.MYSQL_HOST,</span><br><span class="line">            db=bgm.settings.MYSQL_DBNAME,</span><br><span class="line">            user=bgm.settings.MYSQL_USER,</span><br><span class="line">            password=bgm.settings.MYSQL_PASSWORD,</span><br><span class="line">            charset=<span class="string">&#x27;utf8mb4&#x27;</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                     item: <span class="type">Union</span>[SubjectItem, RelationItem],</span></span><br><span class="line"><span class="params">                     spider</span>):</span><br><span class="line">        query = self.dbpool.runInteraction(self.do_insert, item)</span><br><span class="line">        <span class="comment"># 处理异常</span></span><br><span class="line">        query.addErrback(self.handle_error, item, spider)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_error</span>(<span class="params">self, failure, item, spider</span>):</span><br><span class="line">        <span class="comment"># 处理异步插入的异常</span></span><br><span class="line">        <span class="built_in">print</span>(failure)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_insert</span>(<span class="params">self, cursor, item</span>):</span><br><span class="line">        <span class="comment"># 会从dbpool取出cursor</span></span><br><span class="line">        <span class="comment"># 执行具体的插入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, SubjectItem):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> item[<span class="string">&#x27;name&#x27;</span>]:</span><br><span class="line">                item[<span class="string">&#x27;name&#x27;</span>] = item[<span class="string">&#x27;name_cn&#x27;</span>]</span><br><span class="line">            <span class="comment"># if not item[&#x27;name_cn&#x27;]:</span></span><br><span class="line">            <span class="comment">#     item[&#x27;name_cn&#x27;] = item[&#x27;name&#x27;]</span></span><br><span class="line">            insert_sql = Subject.insert(</span><br><span class="line">                **item</span><br><span class="line">            ).on_conflict_replace().sql()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(item, RelationItem):</span><br><span class="line">            insert_sql = Relation.insert(</span><br><span class="line">                <span class="built_in">id</span>=<span class="string">f&#x27;<span class="subst">&#123;item[<span class="string">&quot;source&quot;</span>]&#125;</span>-<span class="subst">&#123;item[<span class="string">&quot;target&quot;</span>]&#125;</span>&#x27;</span>,</span><br><span class="line">                **item</span><br><span class="line">            ).on_conflict_replace().sql()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cursor.execute(*insert_sql)</span><br><span class="line">    <span class="comment"># 拿传进的cursor进行执行，并且自动完成commit操作</span></span><br></pre></td></tr></table></figure><p>而在处理上, 也跟之前 mongodb 有点不一样...</p><p>之前使用 mongo 的时候, 都是直接从 mongo 里面把数据读出来, 处理完了再写会数据库.但是在使用 mysql 的时候就不太行的通了. 因为在我的使用场景下，相比 mongo, mysql 太慢了.如果把对应的关系和条目从 mysql 里读出来再处理, 有 90%的时间都花在 io 上, 而且不是一两个小时能处理完的. 所以只能选择一开始把 mysql 里的所有数据读到内存, 放在 mysql 里面处理.</p><p>而大概 20w 条条目, 20w 条条目间关系, 全都读到数据库里大概需要 1400MB 左右的内存, 我的服务器已经处理不了了, 只能先把数据库从服务器上下载下来, 然后再进行处理.</p><p>之前发在 bgm 上之后有人提议说增量更新新的条目, 正好现在已经把主要的数据爬完了, 还剩下一些旧的条目, 只要写一个额外的爬虫定期处理<a href="https://bgm.tv/wiki">bangumi wiki 计划</a>页面显示的更改就好了.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本项目已弃坑。&lt;/p&gt;
&lt;p&gt;先放成品 &lt;a href=&quot;http://bgm-ip-viewer.trim21.cn&quot;&gt;bgm-ip-viewer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 bgm 上看到有人说现在的关联图只有一层, 看起来不太方便, 就爬了全站数据做了这么个东西.&lt;/p&gt;</summary>
    
    
    
    
    <category term="nodejs" scheme="https://blog.trim21.me/tag/nodejs/"/>
    
    <category term="bgm" scheme="https://blog.trim21.me/tag/bgm/"/>
    
  </entry>
  
  <entry>
    <title>基于asyncio的web框架aiohttp</title>
    <link href="https://blog.trim21.me/2018/10/python-aiohttp.html"/>
    <id>https://blog.trim21.me/2018/10/python-aiohttp.html</id>
    <published>2018-10-05T09:42:21.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>本来想扯一通标准库里添加了<code>asyncio</code>的意义, 什么统一了异步框架, 什么方便代码前移之类的了.<br>然后发现原来大家也都是用装饰器+生成器来写的, 好像也没啥区别...</p><p>迁移的主要阻力也不是各个框架实现异步的方式不同, 而是用到了框架的某些特性, 在其他框架里可能没有, <code>asyncio</code>成为标准库也改变不了这一点.</p><p>不过 python3.4 3.5 3.6 添加了很多新功能,语言层面的异步支持越来越好了</p><p>在 3.4 就是上面说的, 引入了<code>asyncio</code>的标准库.</p><p>3.5 有了一系列的 bug fix ,可以见<a href="https://aiohttp.readthedocs.io/en/stable/faq.html#why-is-python-3-5-3-the-lowest-supported-version">why-is-python-3-5-3-the-lowest-supported-version</a>, 还支持了<code>async/await</code>语法.</p><span id="more"></span><p>不过 3.5 的时候<code>async/await</code>还不是关键字, 还可以给<code>async</code>赋值, 所以到了 python3.7 的时候挂了一堆库, 因为他们用了<code>async</code>当变量...</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.version_info) <span class="comment"># 3.5.4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    r = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">async</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取EventLoop:</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 执行coroutine</span></span><br><span class="line">loop.run_until_complete(hello())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>会输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Hello world!</span><br><span class="line">Hello again!</span><br></pre></td></tr></table></figure><p>但是如果到了 python3.7, 会报错<code>SyntaxError</code>, 也因为这个原因挂了一堆库.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  File <span class="string">&quot;app.py&quot;</span>, line 14</span><br><span class="line">    async = 1</span><br><span class="line">          ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>比如说 twisted, python3.7.0 是 6 月 27 号发布的, 但是直到到前两天(2018-10-05), pypi 上的最新版本还不能正常运行...</p><p>说了半天没用的...</p><p>最近在折腾的 python 框架 aiohttp 其实没有这个问题. 因为 aiohttp3.x.x 的最低版本要求就是 3.5.4, 从一开始就用到了<code>async/await</code>, 自然也不会有某个开发者把 async 再当作函数参数或者变量来赋值.</p><p>出于好奇, 还是了解了一下 aiohttp 这个框架, 写了几个小玩具.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">route = web.RouteTableDef()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@route.get(<span class="params"><span class="string">&#x27;/about&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">about</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=request.app.version + <span class="string">&#x27; author Trim21&lt;trim21me@gmail.com&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@web.middleware</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">middleware</span>(<span class="params">request, handler</span>):</span><br><span class="line">    <span class="comment"># before handle request</span></span><br><span class="line">    resp = <span class="keyword">await</span> handler(request)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>():</span><br><span class="line">    app = web.Application(middlewares=[middleware, ])</span><br><span class="line">    app.version = <span class="string">&#x27;0.0.1&#x27;</span></span><br><span class="line">    app.add_routes([</span><br><span class="line">        web.get(<span class="string">&#x27;/&#x27;</span>, index, name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">    ])</span><br><span class="line">    app.add_routes(route)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">web.run_app(create_app())</span><br></pre></td></tr></table></figure><p>一个简单的例子, (如果需要数据库的话, 官方的例子是把 mongo 的连接池绑在了<code>app.mongo</code>上.)</p><p>前面提到了, 语言层面的异步支持是越来越好了, 但是类库的支持还是有些匮乏.</p><p>mongodb 和 redis 的支持还算可以, mongodb 的官方自己写了<a href="https://github.com/mongodb/motor"><code>motor</code></a>, aiohttp 的开发者写了<a href="https://github.com/aio-libs/aioredis"><code>aioredis</code></a>.</p><p>但是如果想找一个异步的关系型数据库的 ORM 就非常难了. <a href="http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/">SQLAlchemy 的作者曾经写过一篇文章</a>, 说因为 python 本身就很慢, 所以异步也没有意义, 反而比同步还要慢.</p><p><del>但我还是相信 python, 会有那么一天变快的(</del></p><p>异步的 SQL ORM 主要有这么几个</p><ol><li><a href="https://github.com/05bit/peewee-async"><code>peewee-async</code></a></li><li><a href="https://github.com/fantix/gino"><code>gino</code></a></li></ol><p><code>gino</code>直接 pass, 因为目前只支持 postgreSQL.</p><p><code>peewee-async</code>的问题是, 他其实是基于 peewee 的, 你要通过 peewee 来定义你的模块, 然后用<code>peewee-async</code>给的一个<code>Manager</code>来异步调用.</p><p>举个例子, 他的异步代码是长这样的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> peewee</span><br><span class="line"><span class="keyword">from</span> peewee_async <span class="keyword">import</span> Manager, PostgresqlDatabase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(peewee.Model):</span><br><span class="line">    username = peewee.CharField(max_length=<span class="number">40</span>, unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span>(peewee.Model):</span><br><span class="line">    user = peewee.ForeignKeyField(model=User, backref=<span class="string">&#x27;tweets&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objects = Manager(PostgresqlDatabase(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line">objects.database.allow_sync = <span class="literal">False</span>  <span class="comment"># this will raise AssertionError on ANY sync call</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_async_func</span>():</span><br><span class="line">    user0 = <span class="keyword">await</span> objects.create(User, username=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    user1 = <span class="keyword">await</span> objects.get(User, <span class="built_in">id</span>=user0.<span class="built_in">id</span>)</span><br><span class="line">    user2 = <span class="keyword">await</span> objects.get(User, username=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    <span class="comment"># All should be the same</span></span><br><span class="line">    <span class="built_in">print</span>(user0.<span class="built_in">id</span>, user1.<span class="built_in">id</span>, user2.<span class="built_in">id</span>)</span><br><span class="line">    <span class="built_in">print</span>(user0.tweets)  <span class="comment"># raise exception here</span></span><br></pre></td></tr></table></figure><p>像这个例子比较简单, 就只有一个外键, 还添加了<code>backref</code>, 就容易出问题了.</p><p>因为本身是异步框架, 所以同步的代码都会阻塞整个事件循环, 在使用 orm 的时候会先设置禁止同步链接数据库, 只允许异步链接. 但是如果用了外键, peewee 在你试图获取对应的属性的时候就会链接数据库, 取回对应的数据. 所以如果用了外键, 在查询和使用实例的时候总要小心翼翼的, 以避免触发同步查询.</p><p>也许不用外键, 直接存 id 进去, 不依赖数据库的约束, 而在 web 层面约束可能好一些, 不会出现类似的问题.</p><p>ORM 扯完了, 几个经常会用到的东西.</p><p>模板: <a href="https://github.com/aio-libs/aiohttp-jinja2"><code>aiohttp-jinja2</code></a></p><p>session: <a href="https://github.com/aio-libs/aiohttp-session"><code>aiohttp-session</code></a></p><p>辅助的开发服务器, 支持 livereload 和 hotreload<a href="https://github.com/aio-libs/aiohttp-devtools"><code>aiohttp-devtools</code></a></p><p>devtools 有一些坑, 主要是项目的 readme 不是很全, 主要还是要靠 cli 的 help 信息和源码...</p><p>比如, 我的项目结构是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├─ Dockerfile</span><br><span class="line">├─ README.md</span><br><span class="line">├─ requirements.txt</span><br><span class="line">└──app</span><br><span class="line">   ├─ main.py</span><br><span class="line">   ├─static</span><br><span class="line">   │  └─css</span><br><span class="line">   │    └── 1.css</span><br><span class="line">   └──templates</span><br><span class="line">      └── index.html</span><br></pre></td></tr></table></figure><p>这里有一个潜在的坑, 如果你要在<code>project</code>目录下直接启动服务器的话, 是不能提供<code>app-path</code>的, 而是用通过<code>--root</code>来启动, 比如说<code>adev runserver --root app</code></p><p>但是如果你的<code>pwd</code>是<code>app</code>, 此时不需要提供<code>root-path</code>, 只需要提供<code>app-apth</code>, 启动命令变为<code>adev runserver main.py</code></p><p>贴一下<code>runserver</code>的 help 信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: adev runserver [OPTIONS] [APP_PATH]</span><br><span class="line"></span><br><span class="line">  Run a development server for an aiohttp apps.</span><br><span class="line"></span><br><span class="line">  Takes one argument &quot;app-path&quot; which should be a path to either a directory</span><br><span class="line">  containing a recognized default file (&quot;app.py&quot; or &quot;main.py&quot;) or to a</span><br><span class="line">  specific file. Defaults to the environment variable &quot;AIO_APP_PATH&quot; or &quot;.&quot;.</span><br><span class="line"></span><br><span class="line">  The app path is run directly, see the &quot;--app-factory&quot; option for details</span><br><span class="line">  on how an app is loaded from a python module.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -s, --static DIRECTORY          Path of static files to serve, if excluded</span><br><span class="line">                                  static files aren&#x27;t served. env variable:</span><br><span class="line">                                  AIO_STATIC_STATIC</span><br><span class="line">  --root DIRECTORY                Root directory project used to qualify other</span><br><span class="line">                                  paths. env variable: AIO_ROOT</span><br><span class="line">  --static-url TEXT               URL path to serve static files from, default</span><br><span class="line">                                  &quot;/static/&quot;. env variable: AIO_STATIC_URL</span><br><span class="line">  --livereload / --no-livereload  Whether to inject livereload.js into html</span><br><span class="line">                                  page footers to autoreload on changes. env</span><br><span class="line">                                  variable AIO_LIVERELOAD</span><br><span class="line">  --host TEXT                     host used when referencing livereload and</span><br><span class="line">                                  static files, if blank host is taken from</span><br><span class="line">                                  the request header with default of</span><br><span class="line">                                  localhost. env variable AIO_HOST</span><br><span class="line">  --debug-toolbar / --no-debug-toolbar</span><br><span class="line">                                  Whether to enable debug toolbar. env</span><br><span class="line">                                  variable: AIO_DEBUG_TOOLBAR</span><br><span class="line">  --app-factory TEXT              name of the app factory to create an</span><br><span class="line">                                  aiohttp.web.Application with, if missing</span><br><span class="line">                                  default app-factory names are tried. This</span><br><span class="line">                                  can be either a function with signature &quot;def</span><br><span class="line">                                  create_app(loop): -&gt; Application&quot; or &quot;def</span><br><span class="line">                                  create_app(): -&gt; Application&quot; or just an</span><br><span class="line">                                  instance of aiohttp.Application. env</span><br><span class="line">                                  variable AIO_APP_FACTORY</span><br><span class="line">  -p, --port INTEGER              Port to serve app from, default 8000. env</span><br><span class="line">                                  variable: AIO_PORT</span><br><span class="line">  --aux-port INTEGER              Port to serve auxiliary app (reload and</span><br><span class="line">                                  static) on, default port + 1. env variable:</span><br><span class="line">                                  AIO_AUX_PORT</span><br><span class="line">  -v, --verbose                   Enable verbose output.</span><br><span class="line">  --help                          Show this message and exit.</span><br></pre></td></tr></table></figure><p>其中, <code>-s, --static</code>因为实际上静态文件要通过<code>--aux-port</code>去访问, 所以感觉有些鸡肋.</p><p>也就是说, 如果正常的服务器启动在<code>6001</code>端口, 而<code>aux-server</code>启动在<code>6002</code>端口, 我们要使用这个参数代理的静态文件的话, 要访问<code>http://localhost:6002/static/1.css</code>, 而正常我们会把静态文件放在同一个域名下, 也就是<code>http://localhost:6001/static/1.css</code>, 所以我的选择是直接添加一个<code>web.static</code>的路由, 而不是使用的这个功能.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来想扯一通标准库里添加了&lt;code&gt;asyncio&lt;/code&gt;的意义, 什么统一了异步框架, 什么方便代码前移之类的了.&lt;br&gt;
然后发现原来大家也都是用装饰器+生成器来写的, 好像也没啥区别...&lt;/p&gt;
&lt;p&gt;迁移的主要阻力也不是各个框架实现异步的方式不同, 而是用到了框架的某些特性, 在其他框架里可能没有, &lt;code&gt;asyncio&lt;/code&gt;成为标准库也改变不了这一点.&lt;/p&gt;
&lt;p&gt;不过 python3.4 3.5 3.6 添加了很多新功能,语言层面的异步支持越来越好了&lt;/p&gt;
&lt;p&gt;在 3.4 就是上面说的, 引入了&lt;code&gt;asyncio&lt;/code&gt;的标准库.&lt;/p&gt;
&lt;p&gt;3.5 有了一系列的 bug fix ,可以见&lt;a href=&quot;https://aiohttp.readthedocs.io/en/stable/faq.html#why-is-python-3-5-3-the-lowest-supported-version&quot;&gt;why-is-python-3-5-3-the-lowest-supported-version&lt;/a&gt;, 还支持了&lt;code&gt;async/await&lt;/code&gt;语法.&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
  </entry>
  
  <entry>
    <title>使用webpack打包userscript</title>
    <link href="https://blog.trim21.me/2018/10/webpack-userscript.html"/>
    <id>https://blog.trim21.me/2018/10/webpack-userscript.html</id>
    <published>2018-10-03T03:15:35.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>原本用的是 grunt 来打包 webpack, 但是 grunt 只是依赖于简单的字符串替换和拼接, 效率过低.</p><p>既然 webpack 可以用来打包别的 js 文件, 那么打包一个 userscript 肯定也没什么问题, 甚至大材小用了.</p><p>所以自己写了一个模板<a href="https://github.com/Trim21/webpack-userscript-template">webpack-userscript-template</a></p><span id="more"></span><p>因为找了一下, 发现相应的工具还是有些缺陷的.</p><p>主要有两个问题:</p><ol><li>生成 userscript 的 meta 注释</li><li>没有一个好用的 http client 库.</li></ol><p>所以为了自己写 userscript 爽一点, 写了两个库解决了这个问题.</p><p><a href="https://github.com/Trim21/userscript-metadata-webpack-plugin">userscript-metadata-webpack-plugin</a>用来解决生成 meta 的问题</p><p><a href="https://github.com/Trim21/axios-userscript-adapter">axios-userscript-adapter</a>是 axios 的一个 adapter, 用来解决进行 http 请求的问题.</p><p>本来 github 上是有一个 webpack-userscript 项目的, 但是里面不知道为什么, 打包用到的是 bash, 理解不了...就自己写了一个<a href="https://github.com/Trim21/webpack-userscript-template">webpack-userscript-template</a></p><p>使用 axios 的时候不要忘了加入 connect 的 meta</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原本用的是 grunt 来打包 webpack, 但是 grunt 只是依赖于简单的字符串替换和拼接, 效率过低.&lt;/p&gt;
&lt;p&gt;既然 webpack 可以用来打包别的 js 文件, 那么打包一个 userscript 肯定也没什么问题, 甚至大材小用了.&lt;/p&gt;
&lt;p&gt;所以自己写了一个模板&lt;a href=&quot;https://github.com/Trim21/webpack-userscript-template&quot;&gt;webpack-userscript-template&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="javascript" scheme="https://blog.trim21.me/tag/javascript/"/>
    
  </entry>
  
  <entry>
    <title>提高userscript开发效率的一些工具</title>
    <link href="https://blog.trim21.me/2018/06/UserScript%E5%BC%80%E5%8F%91.html"/>
    <id>https://blog.trim21.me/2018/06/UserScript%E5%BC%80%E5%8F%91.html</id>
    <published>2018-06-27T20:29:21.000Z</published>
    <updated>2018-10-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这已经是旧文了, 见<a href="/2018/10/webpack-userscript.html" title="使用webpack打包userscript">使用webpack打包userscript</a></p><p>最一开始写 userscript 的时候是在编辑器里修改后复制粘贴到<code>Tampermonkey</code>中,后来觉得实在是太麻烦了,就搜了一下 Github 有没有什么现成的模板可以用.</p><span id="more"></span><p>发现了这个<a href="https://github.com/turboteddy/userscript-grunt-template">turboteddy/userscript-grunt-template</a>. 用了一下发现比原来效率高了不止一点. 就根据一些个人习惯稍微改了一下</p><p>因为我用的用户脚本扩展是<code>Tampermonkey</code>,所以下文中的<code>Tampermonkey</code>也包括了其他的同类插件.</p><p>我自己实际使用的代码在这里<a href="https://github.com/Trim21/userscript-grunt-template">Trim21/userscript-grunt-template</a>, 下面的内容以这个 repo 为准</p><h2 id="最起码需要的几个功能">最起码需要的几个功能</h2><ul><li>代码分块,不同类型的代码放在不同的文件中,比如要插入网页的 html 要放在<code>html</code>文件中,样式对应的代码放在<code>css</code>文件中,这样同时拥有了编辑器或者 IDE 的自动补全.</li><li>LiveReload,即修改代码后自动刷新网页查看效果.</li></ul><p>分成几部分来说</p><p>首先是代码分块, 这点用一个打包工具就可以做到了,比如我这里用到的是<code>Grunt</code>,因为<code>Grunt</code>有人已经写好了一个<a href="https://github.com/Zod-/grunt-userscript-meta">grunt-userscript-meta</a>,用来直接生成 userscript 开头的 meta 信息, 那么自动补全的问题也随之解决了.</p><h3 id="开始">开始</h3><p>Grunt 的介绍我就不贴了 不了解的话也不会太影响使用 有兴趣的话可以看<a href="https://javascript.ruanyifeng.com/tool/grunt.html">阮一峰的 Grunt 介绍</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:Trim21/userscript-grunt-template.git</span><br><span class="line"><span class="built_in">cd</span> userscript-grunt-template</span><br><span class="line">npm i</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>更改<code>src/js/index.js</code>中的内容,grunt 就会重新打包生成<code>dist/latest</code>中 js 的内容</p><p>所有的原文件都在<code>src</code>文件夹中,<code>html</code>和<code>css</code>要在对应的文件夹里.</p><p>如果在 js 中想要引用对应的内容,要用到<code>/* @include ../html/page1.html */</code>这样的语法.(基于<a href="https://github.com/jsoverson/grunt-preprocess"><code>grunt-preprocess</code></a>)</p><p>比如说要使用<code>GM_addStyle</code>,但是字符串又太长, 就可以把对应的样式放在<code>css/page1.css</code>,然后在 js 中这样写</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">GM_addStyle</span>(<span class="string">&quot;/* @include ../css/page1.css */&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>css/page1.css</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#my-userscript-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会被打包成</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">GM_addStyle</span>(<span class="string">&quot;#my-userscript-wrap&#123;background-color:red&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>虽然丧失了部分可读性,但我们也不修改打包后的文件对吧...</p><p>写代码的问题是解决了,还有让代码起效的问题. 总不能一次一次手动复制吧.</p><h3 id="解决方法如下">解决方法如下</h3><p>首先,允许<code>Tampermonkey</code>扩展访问本地文件</p><p>右键扩展的图标, 选择管理扩展程序</p><p><img src="../static/bd69bf14ly1fsqd1me9o7j205a05fdfu.jpg" alt="1"></p><p>在其中找到<code>允许访问文件网址</code>(也就是以<code>file://</code> 开头的 url)</p><p><img src="../static/bd69bf14ly1fsqd0vt6d5j20je0kujt9.jpg" alt="2"></p><p>首先说下<code>Tampermonkey</code>的行为,如果脚本<code>@require</code>的是一个本地文件,那么每次加载的脚本的时候都会加载最新的本地文件. 如果<code>@require</code>的是<code>http</code>或者<code>https</code>协议的文件,那<code>Tampermonkey</code>会在第一次运行之后把文件内容缓存, 如果缓存存在, 就算文件内容更改了, 也不会更新.(但是可以手动更新). 所以不能直接通过<code>file</code>协议安装打包后的脚本,因为这样会导致重新打包后生效的还是旧代码. 需要通过<code>@require</code>这个 meta 来解决这个问题.</p><p>所要新建一个脚本,保持各种<code>meta</code>信息与你实际使用的用户脚本的<code>meta</code>相同,然后在最后一行加上这样的一行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @require      file:///path/to/your/userscript.user.js</span></span><br></pre></td></tr></table></figure><p>把路径改成对应的<code>dist/latest/filename.user.js</code>即可.</p><p>这样,被 grunt 编译之后的脚本就能被<code>Tampermonkey</code>运行了.</p><p>而本体可以留空.</p><p>在之前运行了<code>npm run watch</code>命令,这个命令实际上是调用<code>grunt-contrib-watch</code>对应的代码,检测文件变化,运行相应的<code>Grunt</code>任务. 这个<code>Grunt</code>插件提供了一个<code>livereload</code>的服务端(默认端口号是 35729), 在这里, 使用<a href="https://chrome.google.com/webstore/detail/jnihajbhpnppcggbcgedagnkighmdlei">LiveReload 提供的插件</a>. 只要点一下右上角的扩展图标,在文件更改,在<code>Grunt</code>检测到文件变化,重新打包文件的时候, 就会通知插件, 刷新你点击图标时对应的选项卡.</p><p>这样,就把<code>js</code>和<code>html</code>,<code>css</code>给拆分开了, 修改<code>html</code>和<code>css</code>的时候也能享受编辑器提供的自动补全功能了, 而不用在<code>js</code>里修改字符串.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这已经是旧文了, 见&lt;a href=&quot;/2018/10/webpack-userscript.html&quot; title=&quot;使用webpack打包userscript&quot;&gt;使用webpack打包userscript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最一开始写 userscript 的时候是在编辑器里修改后复制粘贴到&lt;code&gt;Tampermonkey&lt;/code&gt;中,后来觉得实在是太麻烦了,就搜了一下 Github 有没有什么现成的模板可以用.&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="javascript" scheme="https://blog.trim21.me/tag/javascript/"/>
    
  </entry>
  
  <entry>
    <title>bash和zsh的自动补全</title>
    <link href="https://blog.trim21.me/2017/12/bash-zsh-autocompltion.html"/>
    <id>https://blog.trim21.me/2017/12/bash-zsh-autocompltion.html</id>
    <published>2017-12-09T01:58:46.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>最近在给一个开源项目贡献代码,想要给他加上相应的自动补全功能</p><p><a href="https://github.com/BGmi/BGmi">BGmi</a>起初只是个 cli 程序,前端单纯的展示已经下载的剧集,后来给前端加了一些订阅功能,但是 cli 的使用频率还是很高,cli 没有自动补全功能总是说不过去,所以就花了一些时间加上了这个功能.</p><span id="more"></span><h2 id="分析一下需求">分析一下需求</h2><p>BGmi 的命令都是同样的结构,<code>bgmi action1 --opt1 arg1 --opt2 arg2</code>,那么我们需要补全的就是所有的 action 和每个 action 相应的选项了.在此之前,是直接<code>add_parser</code>和<code>add_argument</code>相应的 action 和选项.这样是没法进行下一步的,所以首先花了一些时间,所以首先把所有的<code>action</code>和相应的<code>opts</code>存在了一个变量中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">actions_and_arguments = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: ACTION_ADD,</span><br><span class="line">        <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Subscribe bangumi.&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;arguments&#x27;</span>: [</span><br><span class="line">            &#123;<span class="string">&#x27;dest&#x27;</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;kwargs&#x27;</span>: <span class="built_in">dict</span>(metavar=<span class="string">&#x27;name&#x27;</span>, <span class="built_in">type</span>=unicode_, nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">                            <span class="built_in">help</span>=<span class="string">&#x27;Bangumi name&#x27;</span>), &#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;dest&#x27;</span>: <span class="string">&#x27;--episode&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;kwargs&#x27;</span>: <span class="built_in">dict</span>(metavar=<span class="string">&#x27;episode&#x27;</span>,</span><br><span class="line">                            <span class="built_in">help</span>=<span class="string">&#x27;Add bangumi and mark it as specified episode.&#x27;</span>,</span><br><span class="line">                            <span class="built_in">type</span>=<span class="built_in">int</span>), &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: ACTION_DELETE,</span><br><span class="line">        <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Unsubscribe bangumi.&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;arguments&#x27;</span>: [</span><br><span class="line">            &#123;<span class="string">&#x27;dest&#x27;</span>: <span class="string">&#x27;--name&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;kwargs&#x27;</span>: <span class="built_in">dict</span>(metavar=<span class="string">&#x27;name&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">type</span>=unicode_,</span><br><span class="line">                            <span class="built_in">help</span>=<span class="string">&#x27;Bangumi name to unsubscribe.&#x27;</span>), &#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;dest&#x27;</span>: <span class="string">&#x27;--batch&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;kwargs&#x27;</span>: <span class="built_in">dict</span>(action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;No confirmation.&#x27;</span>), &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br></pre></td></tr></table></figure><p>一个<code>list</code>中储存了多个<code>dict</code>,每个<code>dict</code>对应一个<code>action</code>,每个<code>action</code>的选项存在<code>arguments</code>字段中.这里的命名可能有些混乱,写的时候没太注意.</p><p>无论是在 bash 还是 zsh 中,要让 bgmi 有自动补全的功能,都需要一个相应的函数来给 bgmi 命令提供自动补全功能,也就是说,我们是要把上面的一个<code>dict</code>转换成一个字符串. 这种事情,当然就该模板出马了.因为 BGmi 的 api 是由 tornado 提供的,所以就直接用<code>tornado.template</code>了.</p><h2 id="先从-Bash-的自动补全开始">先从 Bash 的自动补全开始</h2><p>参考的<a href="https://segmentfault.com/a/1190000002968878">跟我一起写 shell 补全脚本（Bash 篇）</a></p><p>最终的模板<a href="https://github.com/BGmi/BGmi/blob/0b21db0148f1794219c96520151933904f2918cf/bgmi/others/_bgmi_completion_bash.sh">_bgmi_completion_bash.sh</a></p><h3 id="先说下-bash-的语法">先说下 bash 的语法</h3><p>基本上会用到的数据类型就是字符串和数字了,字符串两边需要加单引号的双引号,或者是反引号.而单引号和双引号还有一些不同.双引号允许转义,而单引号不允许</p><p>shell 的语法跟编程语言的语法有一些不同,感觉 shell 的语法在故意混淆字符串和命令.语句中的一个单词又可以做为命令又可以做为字符串.所以为了避免歧义,需要加上单引号或者双引号.而单引号和双引号又有一些不同.单引号是没有转义的,双引号是有转义的.比如说</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> var=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span> <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span> 233&quot;</span> <span class="comment"># 1 233</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$var&#x27;</span> <span class="comment"># $var</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;`ls`&quot;</span> <span class="comment"># 输出ls命令的输出</span></span><br></pre></td></tr></table></figure><p>在双引号字符串中,以<code>$</code>开头的会被替换成对应的变量,用反引号包起来的内容会视为命令,运行之后把输出替换为字符串的一部分</p><h3 id="然后是具体的代码">然后是具体的代码</h3><p>bash 用来提供自动补全的命令是<code>complete</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">complete --<span class="built_in">help</span></span><br><span class="line">complete: complete [-abcdefgjksuv] [-<span class="built_in">pr</span>] [-DE] [-o option] [-A action]</span><br><span class="line">[-G globpat] [-W wordlist] [-F <span class="keyword">function</span>] [-C <span class="built_in">command</span>] [-X filterpat]</span><br><span class="line">[-P prefix] [-S suffix] [name ...]</span><br><span class="line">    Specify how arguments are to be completed by Readline.</span><br><span class="line"></span><br><span class="line">    For each NAME, specify how arguments are to be completed.  If no options</span><br><span class="line">    are supplied, existing completion specifications are printed <span class="keyword">in</span> a way that</span><br><span class="line">    allows them to be reused as input.</span><br><span class="line"></span><br><span class="line">    Options:</span><br><span class="line">      -p        <span class="built_in">print</span> existing completion specifications <span class="keyword">in</span> a reusable format</span><br><span class="line">      -r        remove a completion specification <span class="keyword">for</span> each NAME, or, <span class="keyword">if</span> no</span><br><span class="line">                NAMEs are supplied, all completion specifications</span><br><span class="line">      -D        apply the completions and actions as the default <span class="keyword">for</span> commands</span><br><span class="line">                without any specific completion defined</span><br><span class="line">      -E        apply the completions and actions to <span class="string">&quot;empty&quot;</span> commands --</span><br><span class="line">                completion attempted on a blank line</span><br><span class="line"></span><br><span class="line">    When completion is attempted, the actions are applied <span class="keyword">in</span> the order the</span><br><span class="line">    uppercase-letter options are listed above.  The -D option takes</span><br><span class="line">    precedence over -E.</span><br><span class="line"></span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns success unless an invalid option is supplied or an error occurs.</span><br></pre></td></tr></table></figure><p>本来<code>complete</code>是支持用另一个命令来进行自动补全的,但是试了试实在是太慢了,所以还是生成了一个 bash 函数.</p><p>因为我是编写了一个<code>_bgmi</code>函数来进行<code>bgmi</code>命令的自动补全,所以此处就应该<code>complete -F _bgmi bgmi</code></p><p>然后就是<code>_bgmi</code>函数本体了. config 太多,只贴了一部分.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">_bgmi</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> pre cur action</span><br><span class="line">    <span class="built_in">local</span> actions bangumi config</span><br><span class="line">    actions=<span class="string">&quot;add delete update cal config filter fetch download list mark search source complete&quot;</span></span><br><span class="line">    config=<span class="string">&quot;BANGUMI_MOE_URL SAVE_PATH DOWNLOAD_DELEGATE MAX_PAGE TMP_PATH DANMAKU_API_URL&quot;</span></span><br><span class="line">    COMPREPLY=()</span><br><span class="line"></span><br><span class="line">    pre=<span class="variable">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span></span><br><span class="line">    cur=<span class="variable">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$COMP_CWORD</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">        COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$actions</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        action=<span class="variable">$&#123;COMP_WORDS[1]&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$action</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            update )</span><br><span class="line">            <span class="built_in">local</span> opts</span><br><span class="line">            opts=<span class="string">&quot;--download -d --not-ignore&quot;</span></span><br><span class="line">            COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$opts</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            filter )</span><br><span class="line">            <span class="built_in">local</span> opts</span><br><span class="line">            opts=<span class="string">&quot;--subtitle --include --exclude --regex&quot;</span></span><br><span class="line">            COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$opts</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            config )</span><br><span class="line">            COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$config</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            cal )</span><br><span class="line">            <span class="built_in">local</span> opts</span><br><span class="line">            opts=<span class="string">&quot;--today -f --force-update --download-cover --no-save&quot;</span></span><br><span class="line">            COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$opts</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">source</span> )</span><br><span class="line">            <span class="built_in">local</span> <span class="built_in">source</span></span><br><span class="line">            <span class="built_in">source</span>=<span class="string">&quot;bangumi_moe mikan_project dmhy&quot;</span></span><br><span class="line">            COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$source</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            search )</span><br><span class="line">            <span class="built_in">local</span> opts</span><br><span class="line">            opts=<span class="string">&quot;--count --regex-filter --download --dupe&quot;</span></span><br><span class="line">            COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$opts</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            download )</span><br><span class="line">            <span class="built_in">local</span> opts</span><br><span class="line">            opts=<span class="string">&quot;--list --mark --status&quot;</span></span><br><span class="line">            COMPREPLY=( $( compgen -W <span class="string">&quot;<span class="variable">$opts</span>&quot;</span> -- <span class="variable">$cur</span> ) )</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">complete -F _bgmi bgmi</span><br><span class="line"></span><br><span class="line"><span class="comment"># run `eval &quot;$(bgmi complete)&quot;` in your bash</span></span><br></pre></td></tr></table></figure><p><code>COMP_WORDS</code>是保存了当前命令行所有输入内容的一个数组,<code>COMP_CWORD</code>是当前正在输入的词的索引.<br>所以,<code>pre=$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</code>是当前正在输入的前一个词,<code>cur=$&#123;COMP_WORDS[COMP_CWORD]&#125;</code>是正在输入的词.</p><p>(这里用<code>$&#123;&#125;</code>包起来跟直接使用<code>$var</code>没有什么区别,只是其他语言的变量前不用加<code>$</code>,用<code>&#123;&#125;</code>包起来个人看起来习惯一点.)</p><p>因为<code>bgmi</code>的命令都是<code>bgmi action args</code>这样的形式,所以先判断<code>COMP_WORDS</code>的大小,如果等于 1,说明还没输出对应的 action,需要补全 action. 如果大于 1, 说明已经输入过了 action,只需要补全对应的选项.</p><p>在 bash 中,生成对应补全选项的命令是<code>compgen</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ compgen --<span class="built_in">help</span></span><br><span class="line">compgen: compgen [-abcdefgjksuv] [-o option] [-A action]</span><br><span class="line"> [-G globpat] [-W wordlist]  [-F <span class="keyword">function</span>] [-C <span class="built_in">command</span>]</span><br><span class="line"> [-X filterpat] [-P prefix] [-S suffix] [word]</span><br><span class="line"></span><br><span class="line">    Display possible completions depending on the options.</span><br><span class="line"></span><br><span class="line">    Intended to be used from within a shell <span class="keyword">function</span> generating possible</span><br><span class="line">    completions.  If the optional WORD argument is supplied, matches against</span><br><span class="line">    WORD are generated.</span><br><span class="line"></span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns success unless an invalid option is supplied or an error occurs.</span><br></pre></td></tr></table></figure><p>我在这里只用到了<code>compgen -W</code> 根据一个<code>wordlist</code>来生成对应的补全.</p><p>接下来只需要把对应的内容根据模板的要求进行修改就可以了.</p><h2 id="Zsh-的自动补全">Zsh 的自动补全</h2><p>参照的这篇文章<a href="https://github.com/spacewander/blogWithMarkdown/issues/32">https://github.com/spacewander/blogWithMarkdown/issues/32</a></p><p>先放个结果...</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_bgmi()&#123;</span><br><span class="line"></span><br><span class="line">    if [[ $&#123;#words&#125; -le 2 ]]</span><br><span class="line">            then</span><br><span class="line">        _alternative \</span><br><span class="line">            &#x27;action:action options:((add\:&quot;Subscribe bangumi.&quot; delete\:&quot;Unsubscribe bangumi.&quot; list\:&quot;List subscribed bangumi.&quot; filter\:&quot;Set bangumi fetch filter.&quot; update\:&quot;Update bangumi calendar and subscribed bangumi episode.&quot; cal\:&quot;Print bangumi calendar.&quot; config\:&quot;Config BGmi.&quot; mark\:&quot;Mark bangumi episode.&quot; download\:&quot;Download manager.&quot; fetch\:&quot;Fetch bangumi.&quot; search\:&quot;Search torrents from data source by keyword&quot; source\:&quot;Select date source bangumi_moe or mikan_project&quot; install\:&quot;Install BGmi front / admin / download delegate&quot; upgrade\:&quot;Check update.&quot; history\:&quot;List your history of following bangumi&quot; ))&#x27;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [[ $&#123;words[(i)cal]&#125; -le $&#123;#words&#125; ]]</span><br><span class="line">        then</span><br><span class="line">        _alternative \</span><br><span class="line">        &#x27;cal:cal options:((--today\:&quot;Show bangumi calendar for today.&quot; -f\:&quot;Get the newest bangumi calendar from bangumi.moe.&quot; --force-update\:&quot;Get the newest bangumi calendar from bangumi.moe.&quot; --download-cover\:&quot;Download the cover to local&quot; --no-save\:&quot;Do not save the bangumi data when force update.&quot; ))&#x27;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compdef _bgmi bgmi</span><br><span class="line"></span><br><span class="line">#usage: eval &quot;$(bgmi complete)&quot;</span><br><span class="line">#if you are using windows, cygwin or babun, try `eval &quot;$(bgmi complete|dos2unix)&quot;`</span><br></pre></td></tr></table></figure><p>zsh 跟 bash 有几点不同</p><p>bash 中的 complete 在 zsh 中是 compdef</p><p>zsh 中用来保存目前所有输入的词组是<code>words</code></p><p>zsh 中要生成对应的提醒的话用的是<code>_alternative</code>等命令,而不是把结果赋值给某个变量.</p><p>其中有这样一个用法</p><p><code>$&#123;words[(i)cal]&#125;</code> 这类似于 js 中的<code>words.indexOf('cal')</code> 而<code>#a</code>就相当于<code>a.length</code></p><p>因为<code>_alternative</code>的功能是最全的,所以我就只用了<code>_alternative</code>这一个命令<br><code>cal:cal options:(( -f\:&quot;Get the newest bangumi calendar from bangumi.moe.&quot; --force-update\:&quot;Get the newest bangumi calendar from bangumi.moe.&quot; ))</code></p><p>如果有两个选项是同样的意思,直接重复输出就可以了,zsh 会自动把他们合并成一行,就像这样 其中 <code>--force-update</code>和<code>-f</code>的帮助信息在我们输入的时候就是相同的.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-189-243-ubuntu ~ $ bgmi cal -</span><br><span class="line">--download-cover      -- Download the cover to local</span><br><span class="line">--force-update    -f  -- Get the newest bangumi calendar from bangumi.moe.</span><br><span class="line">--no-save             -- Do not save the bangumi data when force update.</span><br><span class="line">--today               -- Show bangumi calendar for today.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在给一个开源项目贡献代码,想要给他加上相应的自动补全功能&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BGmi/BGmi&quot;&gt;BGmi&lt;/a&gt;起初只是个 cli 程序,前端单纯的展示已经下载的剧集,后来给前端加了一些订阅功能,但是 cli 的使用频率还是很高,cli 没有自动补全功能总是说不过去,所以就花了一些时间加上了这个功能.&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="shell" scheme="https://blog.trim21.me/tag/shell/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu使用命令重启进入BIOS</title>
    <link href="https://blog.trim21.me/2017/05/ubuntu-reboot-to-BIOS.html"/>
    <id>https://blog.trim21.me/2017/05/ubuntu-reboot-to-BIOS.html</id>
    <published>2017-05-18T18:20:20.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>今天一不小心开了 BIOS 里的快速启动,导致进不去 BIOS 设置也无法选择启动项(我还把 ubuntu 设置成了第一启动项...)百度搜索无果,google 发现了结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl reboot --firmware-setup</span><br></pre></td></tr></table></figure><p>会直接重启进入 BIOS</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天一不小心开了 BIOS 里的快速启动,导致进不去 BIOS 设置也无法选择启动项(我还把 ubuntu 设置成了第一启动项...)百度搜索无果,google 发现了结果&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    
    <category term="ubuntu" scheme="https://blog.trim21.me/tag/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>自动重新构建部署博客</title>
    <link href="https://blog.trim21.me/2017/05/auto-deploy-with-webhook.html"/>
    <id>https://blog.trim21.me/2017/05/auto-deploy-with-webhook.html</id>
    <published>2017-05-13T20:57:28.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>想折腾这个很久了,终于把这个折腾好了.</p><p>现在写博客的流程是,我在本机维护一个 git repo,里面是我所有的文章.然后我写完一篇文章或者修改了文章之后 push 到 github 上去,相应的 github pages 就会根据用来保存文章的 repo 自动最新的状态.</p><p>原本是在自己的 vps 上开了一个服务器处理 webhook, 现在换成了<a href="https://travis-ci.org/">travis-ci</a>来自动部署.</p><span id="more"></span><p>不得不说<a href="https://travis-ci.org/">travis-ci</a>是个好东西. 如果你是开源项目, 是可以免费使用的, 只有 private 的仓库才需要付费.</p><p>写个博客, 自然所有的东西都是公开的, 用他来构建也没什么问题.</p><p>唯一的问题是, 构建之后的部署需要密钥, travis 自然也考虑到了这种问题, 可以在<code>more options</code>- <code>settings</code> - <code>Environment Variables</code>中添加保密的环境变量, 这样一来我们只要去 github 生成一个可以 push 的 token, 用这个 token 又可以避免泄露凭证个第三方, 又可以利用公有服务操作我们的个人仓库.</p><p>首先生成一个 token, 这个比较简单</p><p>因为 github pages 要求 push 到<code>$&#123;username&#125;.github.io</code>的仓库中, 比如我的用户名是<code>trim21</code>, 我就需要把文件 push 到<code>trim21.github.io</code>去, 所以我们需要告诉<code>hexo</code>他要操作的部署的仓库地址.</p><p>而<code>_config.yml</code>里面又不能使用环境变量, 只能每次部署的时候把对应的仓库链接给 echo 进去, 避免泄漏.</p><p>我的<code>_config.yml</code>文件结尾是这样的</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后 echo 到<code>_config.yml</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  repository: https://<span class="variable">$&#123;token&#125;</span>@github.com/Trim21/trim21.github.io&quot;</span> &gt;&gt; ./_config.yml</span><br></pre></td></tr></table></figure><p>就变成了</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://real_token@github.com/Trim21/trim21.github.io</span></span><br></pre></td></tr></table></figure><p>当然, 这里的 token 因为已经在环境变量中设置好了, 所以在配置文件中已经是正确的路径地址了.</p><p>而远程地址是这样的情况下, 就可以正常使用<code>hexo-deploy-git</code>了, 而不需要额外的设置.</p><p>还有一个坑, 因为 travis 不允许从对应的仓库 clone 两次, 所以不能把文章直接 clone 到<code>source/_posts</code>去, 要把之前 clone 的文章移动过去...</p><p>最后贴一下我的 travis 配置.</p><p>其中<code>git clone https://$&#123;token&#125;@github.com/Trim21/trim21.github.io .deploy_git</code>的一步是多余的, 如果你没有提前 clone 的话, hexo 的部署插件会替你 clone.</p><p>而<code>myecho</code>文件里除了把正确的仓库地址 echo 的文件里, 还有对应的<code>hexo g -d</code>, 和调用腾讯云的 api 来刷新 cdn 缓存.</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;8.11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">apt</span> <span class="string">install</span> <span class="string">libtool</span> <span class="string">automake</span> <span class="string">autoconf</span> <span class="string">nasm</span> <span class="string">-y</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">--depth</span> <span class="number">1</span> <span class="string">https://github.com/Trim21/blog.git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$username</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$email</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">blog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mv</span> <span class="string">../blog-posts</span> <span class="string">./source/_posts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://$&#123;token&#125;@github.com/Trim21/trim21.github.io</span> <span class="string">.deploy_git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/Trim21/landscape-plus</span> <span class="string">themes/landscape-plus</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-ahl</span></span><br><span class="line">  <span class="comment"># - chmod +x myecho</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bash</span> <span class="string">myecho</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;想折腾这个很久了,终于把这个折腾好了.&lt;/p&gt;
&lt;p&gt;现在写博客的流程是,我在本机维护一个 git repo,里面是我所有的文章.然后我写完一篇文章或者修改了文章之后 push 到 github 上去,相应的 github pages 就会根据用来保存文章的 repo 自动最新的状态.&lt;/p&gt;
&lt;p&gt;原本是在自己的 vps 上开了一个服务器处理 webhook, 现在换成了&lt;a href=&quot;https://travis-ci.org/&quot;&gt;travis-ci&lt;/a&gt;来自动部署.&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.trim21.me/tag/Linux/"/>
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
    <category term="nodejs" scheme="https://blog.trim21.me/tag/nodejs/"/>
    
    <category term="hexo" scheme="https://blog.trim21.me/tag/hexo/"/>
    
  </entry>
  
  <entry>
    <title>树莓派控制步进电机</title>
    <link href="https://blog.trim21.me/2016/08/rasberrypi-and-stepping-motor.html"/>
    <id>https://blog.trim21.me/2016/08/rasberrypi-and-stepping-motor.html</id>
    <published>2016-08-13T13:53:02.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>有一个题目需要用步进电机控制转速,而且需要控制转动特定的角度,所以找到了步进电机这种东西来拍照.</p><span id="more"></span><p>步进电机内部是通过不同线圈分别通上不同方向的电流,按顺序通一定的电流,就可以让电机转动一个特定的角度.</p><p>之前我以为在转动的时候会一颤一颤的,非常明显的进动,但是实际使用发现并不是这样,实际上上一次转动的角度是非常小的,所以并没有非常的明显的卡顿感.</p><p>我用的电机可以看出来一共有 5 根线,一根正极,其他四根分别接驱动板的四个信号输出端.然后用树莓派的 GPIO 分别输出信号给驱动板.驱动板对相应信号作出反应,会输出相应的电压.</p><p>驱动板我用的是 L298N,这个板子在淘宝店上有好几家店卖具体样子不同的产品,这个板子上面有四个<strong>使能</strong>,这词我琢磨了半天没懂,后来才发现是<code>enable</code>...所以其实就是在通上 5V 的电压之后就可以用单片机控制电压输出与否了.</p><p>我买的板子上的使能是用跳线做为使能的,就是用跳线短接的时候就已经使能了.</p><p>但是我傻傻的吧 gpio 接上去了,问题就出来了.....我眼看着我的树莓派的灯越来越暗,然后树莓派被烧了.</p><p>其实就是把跳线短接就已经使能了.这个时候把树莓派的 gpio 口输出接到驱动板的 in 口就可以控制了.</p><p>当时用的程序,这个程序是控制了我的电机旋转了接近 180°.</p><p>python3</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> io</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">io.setmode(io.BOARD)</span><br><span class="line"></span><br><span class="line">out1=<span class="number">12</span></span><br><span class="line">out2=<span class="number">16</span></span><br><span class="line">out3=<span class="number">18</span></span><br><span class="line">out4=22s</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Setup leds</span></span><br><span class="line">    io.setup(out1,io.OUT)</span><br><span class="line">    io.output(out1,<span class="number">0</span>)</span><br><span class="line">    io.setup(out2,io.OUT)</span><br><span class="line">    io.output(out2,<span class="number">0</span>)</span><br><span class="line">    io.setup(out3,io.OUT)</span><br><span class="line">    io.output(out3,<span class="number">0</span>)</span><br><span class="line">    io.setup(out4,io.OUT)</span><br><span class="line">    io.output(out4,<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># Run blinking forever</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            io.output(out1,<span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            io.output(out4,<span class="number">0</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            io.output(out2,<span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            io.output(out1,<span class="number">0</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            io.output(out3,<span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            io.output(out2,<span class="number">0</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            io.output(out4,<span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            io.output(out3,<span class="number">0</span>)</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    <span class="comment"># Stop on Ctrl+C and clean up</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        io.cleanup()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有一个题目需要用步进电机控制转速,而且需要控制转动特定的角度,所以找到了步进电机这种东西来拍照.&lt;/p&gt;</summary>
    
    
    
    <category term="硬件" scheme="https://blog.trim21.me/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
    <category term="树莓派" scheme="https://blog.trim21.me/tag/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装matplotlib</title>
    <link href="https://blog.trim21.me/2016/07/matplotlib.html"/>
    <id>https://blog.trim21.me/2016/07/matplotlib.html</id>
    <published>2016-07-25T11:26:07.000Z</published>
    <updated>2016-07-25T11:26:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>(可恶,git 用的不熟练,把 commit 丢了...重写文章)</p><p>总结一下,在安装了<code>NumPy</code>之后还需要安装</p><ol><li>freetype</li><li>libpng</li><li>libffi</li><li>cairocffi</li></ol><span id="more"></span><p>freetype 下载地址 <a href="http://download.savannah.gnu.org/releases/freetype/">http://download.savannah.gnu.org/releases/freetype/</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.savannah.gnu.org/releases/freetype/freetype-2.6.5.tar.gz</span><br><span class="line">tar xvf freetype-2.6.5</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>libpng 和 libffi 都在 apt 上有</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  artic git:(master) ✗ search libffi</span><br><span class="line">libffi-dev - Foreign Function Interface library (development files)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  artic git:(master) ✗ search libpng</span><br><span class="line">libpng12-0 - PNG library - runtime</span><br><span class="line">libpng12-dev - PNG library - development</span><br></pre></td></tr></table></figure><p>直接 apt-get 安装即可</p><p>调用<code>matplotlib</code>的时候图像式全黑的,提示我安装<code>cairocffi</code>,是 pip 上的包,安装了第三个之后直接<code>pip</code>安装这个就可以了.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;(可恶,git 用的不熟练,把 commit 丢了...重写文章)&lt;/p&gt;
&lt;p&gt;总结一下,在安装了&lt;code&gt;NumPy&lt;/code&gt;之后还需要安装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;freetype&lt;/li&gt;
&lt;li&gt;libpng&lt;/li&gt;
&lt;li&gt;libffi&lt;/li&gt;
&lt;li&gt;cairocffi&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://blog.trim21.me/tag/python/"/>
    
  </entry>
  
  <entry>
    <title>利用hexo和GitHub pages服务搭建博客</title>
    <link href="https://blog.trim21.me/2016/04/build-blog-whith-hexo-and-github-pages.html"/>
    <id>https://blog.trim21.me/2016/04/build-blog-whith-hexo-and-github-pages.html</id>
    <published>2016-04-15T17:03:39.000Z</published>
    <updated>2022-08-14T16:22:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>使用 GitHub actions 自动部属博客到 GitHub pages。</p><span id="more"></span><h2 id="GitHub-Pages-介绍">GitHub Pages 介绍</h2><p>github pages 是 github 提供的服务，github 会为特定仓库的默认分支（比如 <code>$&#123;username&#125;.github.io</code> ）或者其他仓库的 <code>gh-pages</code> 分支提供静态文件服务。</p><p><code>$&#123;username&#125;.github.io</code> 仓库的文件会直接放在 <code>$&#123;username&#125;.github.io</code> 域名的根目录下，其他的仓库则会放在<code>/$&#123;repo_name&#125;/</code> 子目录下。</p><p>比如，我在 <code>blog</code> 仓库下创建 <code>gh-pages</code> 分支，在根目录创建一个 <code>index.html</code> 文件。以我的用户名<code>trim21</code>为例，访问 <code>https://trim21.github.io/blog/index.html</code> 就可以正常看到文件。</p><h2 id="GitHub-Actions">GitHub Actions</h2><p>2019 年 GitHub 上线了自己的 CI，<a href="https://docs.github.com/cn/actions">GitHub Actions</a>，在此之前大家一般会使用 travis CI 或者 circle CI 等。但是直接用 github actions 可以避免额外注册账号，设置 github access token 等等权限问题。</p><p>有了 github actions 之后就不再需要博客提供的各种部属插件了，只需要在 github actions 中构建博客，并且把生成的<code>public/</code>文件夹推到<code>gh-pages</code> 分支就可以了。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">yarn</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">yarn</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">          <span class="attr">commit_message:</span> <span class="string">deploy</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">cname:</span> <span class="string">blog.trim21.me</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 GitHub actions 自动部属博客到 GitHub pages。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.trim21.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="nodejs" scheme="https://blog.trim21.me/tag/nodejs/"/>
    
    <category term="git" scheme="https://blog.trim21.me/tag/git/"/>
    
    <category term="github" scheme="https://blog.trim21.me/tag/github/"/>
    
  </entry>
  
</feed>
