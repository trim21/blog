<!DOCTYPE html><html lang="zh-cmn-Hans-CN"><head><meta charset="utf-8"><meta name="referrer" content="no-referrer"><link rel="preload" href="https://cdn.jsdelivr.net/npm/fancybox@3.0.1/dist/css/jquery.fancybox.css" integrity="sha256-iK+zjGHeeTQux1laFiGc4EZWPacH5acc6CnZBGji1ns=" as="style" crossorigin="anonymous"><link rel="preload" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&amp;display=swap" as="style" crossorigin="anonymous"><link rel="preload" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" as="style" crossorigin="anonymous"><link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" as="script" crossorigin="anonymous"><link rel="preload" href="https://cdn.jsdelivr.net/npm/fancybox@3.0.1/dist/js/jquery.fancybox.pack.js" integrity="sha256-VRL0AMrD+7H9+7Apie0Jj4iir1puS6PYigObxCHqf/4=" as="script" crossorigin="anonymous"><title>golang笔记 | Trim21&#39;s Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-91727260-1"></script><script>window.dataLayer = window.dataLayer || [];  function gtag () {dataLayer.push(arguments)};gtag('js', new Date());gtag('config', 'UA-91727260-1');</script><meta name="description" content="一些约定  使用驼峰命名法 首字母小写的变量&#x2F;函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)"><meta property="og:type" content="article"><meta property="og:title" content="golang笔记"><meta property="og:url" content="https://blog.trim21.me/2018/11/learning-golang.html"><meta property="og:site_name" content="Trim21&#39;s Blog"><meta property="og:description" content="一些约定  使用驼峰命名法 首字母小写的变量&#x2F;函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)"><meta property="og:locale"><meta property="og:image" content="https://blog.trim21.me/2018/11/learning-golang.html"><meta property="article:published_time" content="2018-11-01T09:25:15.000Z"><meta property="article:modified_time" content="2022-06-15T03:52:24.540Z"><meta property="article:author" content="Trim21"><meta property="article:tag" content="golang"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.trim21.me/2018/11/learning-golang.html"><link rel="alternative" href="/feed.xml" title="Trim21&#39;s Blog" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">Trim21&#39;s Blog</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives/">Archives</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/feed.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="Search"></a></nav><div id="search-form-wrap"><form action="https://google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button> <input type="hidden" name="sitesearch" value="blog.trim21.me"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-learning-golang" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/11/learning-golang.html" class="article-date"><time datetime="2018-11-01T09:25:15.000Z" itemprop="datePublished">2018-11-01</time></a></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">golang笔记</h1></header><div class="article-entry" itemprop="articleBody"><h2 id="一些约定">一些约定</h2><ol><li>使用驼峰命名法</li><li>首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)</li></ol><span id="more"></span><h2 id="数据类型">数据类型</h2><h3 id="bool">bool</h3><p>布尔, <code>true</code>或者<code>false</code></p><h3 id="string">string</h3><p>字符串, 使用双引号 比如<code>&quot;hello world&quot;</code></p><h3 id="rune">rune</h3><p>类似于字符, 在使用<code>for _, char := range string</code>迭代 string 的时候, char 的类型就是 rune</p><h3 id="int">int</h3><p>未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用<code>int()</code>转化为 int</p><h3 id="byte">byte</h3><p><code>[]byte</code>可以跟 string 互相转化, <code>len(string)</code>的长度实际上就是 string 转化为<code>[]byte</code>之后的长度. 每个 unicode 的长度为 3. 比如说<code>len(&quot;hello world&quot;)==11</code>, 但是<code>len(&quot;你好 世界&quot;)</code>的长度为 3+3+1=7. 每个汉字因为是 unicode 所以为 3.</p><h3 id="指针">指针</h3><p>可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)</p><h3 id="数组">数组</h3><p>用于存放类型相同的一组数据.</p><h4 id="slice">slice</h4><p>可变长度</p><h4 id="array">array</h4><p>长度不可变</p><h3 id="map">map</h3><p>类似于 python 中的 dict, 但是需要指定 key 和 value 的类型</p><p>比如 python 中的<code>Map[str, str]</code>在 golang 中为<code>map[string]string</code>, 这个 map 只能以 string 为 key, 以 string 为 value.</p><p>如果要一个可以存储任意数据类型的 map 可以<code>map[string]interface&#123;&#125;</code></p><h3 id="函数">函数</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(arg1 argType1, arg2 argType2)</span></span> (returnType1, returnType2)&#123;</span><br><span class="line">    main body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang 中, 变量的类型是放在变量名之后的.</p><h3 id="struct">struct</h3><p>结构体, 类似于 python 中的 class.</p><h4 id="定义">定义</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Episode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title   <span class="type">string</span></span><br><span class="line">    Torrent <span class="type">string</span></span><br><span class="line">    Episode <span class="type">int</span></span><br><span class="line">    Time    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化">初始化</h4><p>使用大括号</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e = Episode&#123;</span><br><span class="line">    Title:   <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    Episode: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体的方法">结构体的方法</h4><p>如果要在其上绑定函数, 使用</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(episode *Episode)</span></span> getTitle() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> episode.Title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条用跟其他语言的调用方法类似.</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">e.getTitle()</span><br></pre></td></tr></table></figure><h3 id="接口-interface">接口 interface</h3><p>还没有实际用到, 所以只有一些粗浅的理解.</p><p>interface 接口是为了面向对象而出现的, 一个函数可以参数可以为一系列不特定的类型, 但无所谓具体的类型, 只要这个类型实现了特定的方法即可.</p><p>比如一个<code>writeTo</code>函数接受一个<code>io.Writer</code>的参数</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeTo</span><span class="params">(w io.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.Writer</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要是实现了<code>Write</code>方法的, 输入值和返回值匹配<code>([]byte) (int, error)</code>类型都可以做为这个函数的参数. 比如说默认的标准库<code>os</code>提供的<code>os.Stdout</code>就是一个实现了<code>io.Writer</code>接口的类型. 比如说, 这里就可以以<code>writeTo(os.Stdout)</code>的形式调用.</p><h3 id="channel">channel</h3><p>信道</p><p>go 并发中, 不同<code>goroutine</code>的通信工具.</p><p>无缓冲区或者缓冲区已满的情况下进行写入是阻塞的.</p><p>如果信道为空, 而试图读取也会阻塞.</p><p>只有读取没有写入或者只有写入没有读取会导致死锁.</p><h2 id="并发编程">并发编程</h2><p>golang 提供了<code>go</code>关键词来开启一个<code>goroutine</code>.</p><p>因为 goroutine 函数的返回值是会被丢弃的, 使用回调函数的话又会陷入回调地域中, 所以需要一种额外的方式来接受异步函数的返回结果.</p><p>这里就要贴出那句 go 并发文章常常能看到的话了</p><blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存</p></blockquote><p>而<code>channel</code>, 就是 go 提供的通信的工具. 可以在一个线程中发送数据, 在另一个线程中接收数据. 如果我们要写一个异步爬虫, 就可以开四个线程来爬取数据, 在爬到数据后通过 channel 发送到主线程, 然后在主线程中使用 channel 接受, 交给 pipeline 来处理.</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">costumer</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> each := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;costume %d\n&quot;</span>, each)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> costumer(c)</span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">5</span>; index++ &#123;</span><br><span class="line">        c &lt;- index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>go costumer(channel)</code>启动了一个新的消费者线程, 而主线程自己也是一个<code>goroutine</code>, 虽然跟<code>costumer</code>不在同一个线程中, 但是仍然可以通过 channel 通信, 在这里, 主线程就是生产者, 消费者模型中的生产者.</p><h3 id="并发控制">并发控制</h3><p>有时候并不需要很大的并发量, 比如我们只想起 4 个或者 8 个生产者, 可以使用<code>sync.WaitGroup</code>来进行并发控制.</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> controller = newController(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">20</span>; index++ &#123;</span><br><span class="line">        urls = <span class="built_in">append</span>(urls, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, index))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> controller.dispatchGocoutine(urls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each := <span class="keyword">range</span> controller.output &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;collect output &quot;</span> + each)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> asyncControl <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrg       sync.WaitGroup</span><br><span class="line">    output     <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    goroutineCnt <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newController</span><span class="params">(size <span class="type">int</span>)</span></span> *asyncControl &#123;</span><br><span class="line">    d := <span class="built_in">new</span>(asyncControl)</span><br><span class="line">    d.wrg = sync.WaitGroup&#123;&#125;</span><br><span class="line">    d.output = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    d.goroutineCnt = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, size)</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(controller *asyncControl)</span></span> dispatchGocoutine(urls []<span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        controller.goroutineCnt &lt;- <span class="number">0</span> <span class="comment">// 限制线程数</span></span><br><span class="line">        controller.wrg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> controller.asyncTask(url)</span><br><span class="line">    &#125;</span><br><span class="line">    controller.wrg.Wait() <span class="comment">// 等待至所有分发出去的线程结束</span></span><br><span class="line">    <span class="built_in">close</span>(controller.output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(controller *asyncControl)</span></span> asyncTask(url <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-controller.goroutineCnt</span><br><span class="line">        controller.wrg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// some task here</span></span><br><span class="line">    controller.output &lt;- <span class="string">&quot;processed &quot;</span> + url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为提到在缓冲区已满的情况下写入是阻塞的, 所以可以利用这一点来进行并发控制. <code>goroutineCnt</code>就是用来控制最大线程数的任务. 当我们试图开启一个新的线程的时候, 先向<code>goroutineCnt</code>中进行一次写入, 再开启一个新的任务. 而在工作进程中, 在整个函数执行完成后则从<code>goroutineCnt</code>中进行一次读取. 缓冲区就会空出一位来, 而进行工作分发的线程的阻塞此时就结束了, 在成功写入信道之后则会开启一个新的线程. 保持工作线程数量永远不会超过<code>goroutineCnt</code>的缓冲区长度.</p><p>这个<code>sync.WaitGroup</code>是另一个并发的工具, 因为不能确定其他 goroutine 什么时候才能结束, 所以使用<code>wrk.Wait()</code>来在分发结束后阻塞分发的线程, 在所有分发出去的线程结束后关闭信道.</p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/golang/" rel="tag">golang</a></li></ul></footer></div><code></code><div id="comments" class="archive-article-inner"><script src="https://utteranc.es/client.js" repo="Trim21/blog" issue-term="learning-golang" theme="github-light" crossorigin="anonymous" async></script></div><style></style></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2019/12/caddy-not-working-in-nat.html">caddy在内网中无法更新证书</a></li><li><a href="/2019/12/build-a-nas.html">利用手头已有资源尽可能高配的搭一台nas</a></li><li><a href="/2019/12/pyenv-build-python.html">用pyenv安装python</a></li><li><a href="/2019/10/migrate-to-rime.html">输入法切换到Rime</a></li><li><a href="/2019/06/set-proxy-for-win10-store.html">给win10应用商店设置代理</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tag/Linux/" style="font-size: 10px;">Linux</a> <a href="/tag/bgm/" style="font-size: 10px;">bgm</a> <a href="/tag/git/" style="font-size: 10px;">git</a> <a href="/tag/gitHub/" style="font-size: 10px;">gitHub</a> <a href="/tag/golang/" style="font-size: 10px;">golang</a> <a href="/tag/hexo/" style="font-size: 10px;">hexo</a> <a href="/tag/https/" style="font-size: 10px;">https</a> <a href="/tag/javascript/" style="font-size: 15px;">javascript</a> <a href="/tag/linux/" style="font-size: 10px;">linux</a> <a href="/tag/nas/" style="font-size: 10px;">nas</a> <a href="/tag/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tag/python/" style="font-size: 20px;">python</a> <a href="/tag/shell/" style="font-size: 10px;">shell</a> <a href="/tag/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tag/userscript/" style="font-size: 10px;">userscript</a> <a href="/tag/vue/" style="font-size: 10px;">vue</a> <a href="/tag/windows/" style="font-size: 10px;">windows</a> <a href="/tag/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 10px;">树莓派</a></div></div><div class="widget-wrap"><h3 class="widget-title">Archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">2019 12</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">2019 10</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">2019 06</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">2019 03</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">2018 11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">2018 10</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">2018 06</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">2017 12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">2017 05</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">2016 08</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">2016 07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">2016 04</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Links</h3><div class="widget"><ul><li><a href="https://github.com/trim21" rel="external nofollow noreferrer" target="_blank">GitHub</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2016 - 2019 <a href="mailto:trim21.me@gmail.com" rel="external nofollow noreferrer">Trim21&lt;trim21.me@gmail.com&gt;</a><br>Powered by <a href="//hexo.io/" target="_blank">Hexo</a> . Theme by <a href="https://github.com/Trim21/blog/tree/master/themes/landscape-plus" rel="external nofollow noreferrer" target="_blank">Patched Landscape-plus</a></div></div></footer></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fancybox@3.0.1/dist/css/jquery.fancybox.css" integrity="sha256-iK+zjGHeeTQux1laFiGc4EZWPacH5acc6CnZBGji1ns=" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&amp;display=swap" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/fancybox@3.0.1/dist/js/jquery.fancybox.pack.js" integrity="sha256-VRL0AMrD+7H9+7Apie0Jj4iir1puS6PYigObxCHqf/4=" crossorigin="anonymous"></script><div id="totop"><a title="totop"><img src="/img/scrollup.png"></a></div><script src="/js/script.js"></script></div></body></html>