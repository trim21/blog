<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>golang笔记 | Trim21&#39;s Blog</title>

  
  <meta name="author" content="Trim21">
  

  
  <meta name="description" content="一些约定

使用驼峰命名法
首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)">
  

  
  
  <meta name="keywords" content="golang">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="golang笔记"/>

  <meta property="og:site_name" content="Trim21&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Trim21&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Trim21&#39;s Blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>golang笔记</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/learning-golang.html" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-01T09:25:15.000Z">
          2018-11-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="一些约定">一些约定</h2>
<ol>
<li>使用驼峰命名法</li>
<li>首字母小写的变量/函数只能在包内使用(多按一次 shift 我要累死了, 虽然编辑器有时在小写输入的情况下也会自动补全大写内容, 但有时不是那么聪明)</li>
</ol>
<span id="more"></span>
<h2 id="数据类型">数据类型</h2>
<h3 id="bool">bool</h3>
<p>布尔, <code>true</code>或者<code>false</code></p>
<h3 id="string">string</h3>
<p>字符串, 使用双引号 比如<code>&quot;hello world&quot;</code></p>
<h3 id="rune">rune</h3>
<p>类似于字符, 在使用<code>for _, char := range string</code>迭代 string 的时候, char 的类型就是 rune</p>
<h3 id="int">int</h3>
<p>未分 int8, int16, int32 等等, 可能有些 api 返回的是 uint 类型, 使用<code>int()</code>转化为 int</p>
<h3 id="byte">byte</h3>
<p><code>[]byte</code>可以跟 string 互相转化, <code>len(string)</code>的长度实际上就是 string 转化为<code>[]byte</code>之后的长度. 每个 unicode 的长度为 3. 比如说<code>len(&quot;hello world&quot;)==11</code>, 但是<code>len(&quot;你好 世界&quot;)</code>的长度为 3+3+1=7. 每个汉字因为是 unicode 所以为 3.</p>
<h3 id="指针">指针</h3>
<p>可以指向其他数据类型, 在传值的时候传递指针可以避免比较复杂的数据结构被复制一份.(比如比较大的数据, 结构体等等)</p>
<h3 id="数组">数组</h3>
<p>用于存放类型相同的一组数据.</p>
<h4 id="slice">slice</h4>
<p>可变长度</p>
<h4 id="array">array</h4>
<p>长度不可变</p>
<h3 id="map">map</h3>
<p>类似于 python 中的 dict, 但是需要指定 key 和 value 的类型</p>
<p>比如 python 中的<code>Map[str, str]</code>在 golang 中为<code>map[string]string</code>, 这个 map 只能以 string 为 key, 以 string 为 value.</p>
<p>如果要一个可以存储任意数据类型的 map 可以<code>map[string]interface&#123;&#125;</code></p>
<h3 id="函数">函数</h3>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(arg1 argType1, arg2 argType2)</span></span> (returnType1, returnType2)&#123;</span><br><span class="line">    main body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>golang 中, 变量的类型是放在变量名之后的.</p>
<h3 id="struct">struct</h3>
<p>结构体, 类似于 python 中的 class.</p>
<h4 id="定义">定义</h4>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Episode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title   <span class="type">string</span></span><br><span class="line">    Torrent <span class="type">string</span></span><br><span class="line">    Episode <span class="type">int</span></span><br><span class="line">    Time    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化">初始化</h4>
<p>使用大括号</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e = Episode&#123;</span><br><span class="line">    Title:   <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    Episode: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体的方法">结构体的方法</h4>
<p>如果要在其上绑定函数, 使用</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(episode *Episode)</span></span> getTitle() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> episode.Title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条用跟其他语言的调用方法类似.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">e.getTitle()</span><br></pre></td></tr></table></figure>
<h3 id="接口-interface">接口 interface</h3>
<p>还没有实际用到, 所以只有一些粗浅的理解.</p>
<p>interface 接口是为了面向对象而出现的, 一个函数可以参数可以为一系列不特定的类型, 但无所谓具体的类型, 只要这个类型实现了特定的方法即可.</p>
<p>比如一个<code>writeTo</code>函数接受一个<code>io.Writer</code>的参数</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeTo</span><span class="params">(w io.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.Writer</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要是实现了<code>Write</code>方法的, 输入值和返回值匹配<code>([]byte) (int, error)</code>类型都可以做为这个函数的参数. 比如说默认的标准库<code>os</code>提供的<code>os.Stdout</code>就是一个实现了<code>io.Writer</code>接口的类型. 比如说, 这里就可以以<code>writeTo(os.Stdout)</code>的形式调用.</p>
<h3 id="channel">channel</h3>
<p>信道</p>
<p>go 并发中, 不同<code>goroutine</code>的通信工具.</p>
<p>无缓冲区或者缓冲区已满的情况下进行写入是阻塞的.</p>
<p>如果信道为空, 而试图读取也会阻塞.</p>
<p>只有读取没有写入或者只有写入没有读取会导致死锁.</p>
<h2 id="并发编程">并发编程</h2>
<p>golang 提供了<code>go</code>关键词来开启一个<code>goroutine</code>.</p>
<p>因为 goroutine 函数的返回值是会被丢弃的, 使用回调函数的话又会陷入回调地域中, 所以需要一种额外的方式来接受异步函数的返回结果.</p>
<p>这里就要贴出那句 go 并发文章常常能看到的话了</p>
<blockquote>
<p>不要通过共享内存来通信，而应该通过通信来共享内存</p>
</blockquote>
<p>而<code>channel</code>, 就是 go 提供的通信的工具. 可以在一个线程中发送数据, 在另一个线程中接收数据. 如果我们要写一个异步爬虫, 就可以开四个线程来爬取数据, 在爬到数据后通过 channel 发送到主线程, 然后在主线程中使用 channel 接受, 交给 pipeline 来处理.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">costumer</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> each := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;costume %d\n&quot;</span>, each)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> costumer(c)</span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">5</span>; index++ &#123;</span><br><span class="line">        c &lt;- index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>go costumer(channel)</code>启动了一个新的消费者线程, 而主线程自己也是一个<code>goroutine</code>, 虽然跟<code>costumer</code>不在同一个线程中, 但是仍然可以通过 channel 通信, 在这里, 主线程就是生产者, 消费者模型中的生产者.</p>
<h3 id="并发控制">并发控制</h3>
<p>有时候并不需要很大的并发量, 比如我们只想起 4 个或者 8 个生产者, 可以使用<code>sync.WaitGroup</code>来进行并发控制.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> controller = newController(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">20</span>; index++ &#123;</span><br><span class="line">        urls = <span class="built_in">append</span>(urls, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, index))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> controller.dispatchGocoutine(urls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each := <span class="keyword">range</span> controller.output &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;collect output &quot;</span> + each)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> asyncControl <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrg       sync.WaitGroup</span><br><span class="line">    output     <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    goroutineCnt <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newController</span><span class="params">(size <span class="type">int</span>)</span></span> *asyncControl &#123;</span><br><span class="line">    d := <span class="built_in">new</span>(asyncControl)</span><br><span class="line">    d.wrg = sync.WaitGroup&#123;&#125;</span><br><span class="line">    d.output = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    d.goroutineCnt = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, size)</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(controller *asyncControl)</span></span> dispatchGocoutine(urls []<span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        controller.goroutineCnt &lt;- <span class="number">0</span> <span class="comment">// 限制线程数</span></span><br><span class="line">        controller.wrg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> controller.asyncTask(url)</span><br><span class="line">    &#125;</span><br><span class="line">    controller.wrg.Wait() <span class="comment">// 等待至所有分发出去的线程结束</span></span><br><span class="line">    <span class="built_in">close</span>(controller.output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(controller *asyncControl)</span></span> asyncTask(url <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-controller.goroutineCnt</span><br><span class="line">        controller.wrg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// some task here</span></span><br><span class="line">    controller.output &lt;- <span class="string">&quot;processed &quot;</span> + url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为提到在缓冲区已满的情况下写入是阻塞的, 所以可以利用这一点来进行并发控制. <code>goroutineCnt</code>就是用来控制最大线程数的任务. 当我们试图开启一个新的线程的时候, 先向<code>goroutineCnt</code>中进行一次写入, 再开启一个新的任务. 而在工作进程中, 在整个函数执行完成后则从<code>goroutineCnt</code>中进行一次读取. 缓冲区就会空出一位来, 而进行工作分发的线程的阻塞此时就结束了, 在成功写入信道之后则会开启一个新的线程. 保持工作线程数量永远不会超过<code>goroutineCnt</code>的缓冲区长度.</p>
<p>这个<code>sync.WaitGroup</code>是另一个并发的工具, 因为不能确定其他 goroutine 什么时候才能结束, 所以使用<code>wrk.Wait()</code>来在分发结束后阻塞分发的线程, 在所有分发出去的线程结束后关闭信道.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tag/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>

  




	<section id="comment" class="comment">
		<div id="utterances">
			<script
					src="https://utteranc.es/client.js"
					repo="trim21/blog"
					issue-term="learning-golang"
					crossorigin="anonymous"
					theme="github-light"
					async
			></script>
		</div>
	</section>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" rel="external nofollow noreferrer" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" rel="external nofollow noreferrer" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Trim21
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>